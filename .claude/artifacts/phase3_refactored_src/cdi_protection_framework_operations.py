"""
Extracted operations service from cdi_protection_framework

Automatically generated by God Object Decomposer
"""

import time
from dataclasses import dataclass
import sys
from lib.shared.utilities import get_logger
import os
from typing import Dict, List, Optional, Any
import json


"""Initialize CDI protection framework."""
def __init__(self, storage_path: str = ".claude/.artifacts/cdi_protection"):
        """Initialize CDI protection framework."""
        self.storage_path = Path(storage_path)
        self.storage_path.mkdir(parents=True, exist_ok=True)

        # Initialize crypto module
        self.crypto_module = FIPSCryptoModule()

        # Initialize audit manager
        self.audit_manager = EnhancedDFARSAuditTrailManager(
            str(self.storage_path / "cdi_audit")
        )

        # Initialize databases
        self._initialize_databases()

        # CDI inventory
        self.cdi_assets: Dict[str, CDIAsset] = {}
        self.access_policies: Dict[str, AccessPolicy] = {}
        self.access_requests: Dict[str, DataAccessRequest] = {}

        # Active sessions and access controls
        self.active_sessions: Dict[str, Dict[str, Any]] = {}
        self.access_cache: Dict[str, Dict[str, Any]] = {}

        # Protection keys and certificates
        self.protection_keys: Dict[str, bytes] = {}
        self.key_rotation_schedule: Dict[str, float] = {}

        # Load existing data
        self._load_existing_data()

        # Start background tasks
        self.monitoring_active = False

        logger.info("CDI Protection Framework initialized")

"""Initialize CDI protection databases."""
def _initialize_databases(self):
        """Initialize CDI protection databases."""
        # CDI Assets database
        assets_db = self.storage_path / "cdi_assets.db"
        with sqlite3.connect(assets_db) as conn:
            conn.execute('''
                CREATE TABLE IF NOT EXISTS cdi_assets (
                    asset_id TEXT PRIMARY KEY,
                    name TEXT NOT NULL,
                    description TEXT,
                    classification TEXT NOT NULL,
                    owner TEXT NOT NULL,
                    created_at REAL NOT NULL,
                    updated_at REAL NOT NULL,
                    file_path TEXT,
                    data_type TEXT NOT NULL,
                    sensitivity_markers TEXT,
                    retention_period INTEGER,
                    destruction_date REAL,
                    access_history TEXT,
                    protection_requirements TEXT,
                    metadata TEXT
                )
            ''')

            conn.execute('''
                CREATE INDEX IF NOT EXISTS idx_classification ON cdi_assets(classification)
            ''')
            conn.execute('''
                CREATE INDEX IF NOT EXISTS idx_owner ON cdi_assets(owner)
            ''')

        # Access Policies database
        policies_db = self.storage_path / "access_policies.db"
        with sqlite3.connect(policies_db) as conn:
            conn.execute('''
                CREATE TABLE IF NOT EXISTS access_policies (
                    policy_id TEXT PRIMARY KEY,
                    name TEXT NOT NULL,
                    description TEXT,
                    subject_type TEXT NOT NULL,
                    subject_id TEXT NOT NULL,
                    resource_pattern TEXT NOT NULL,
                    access_level TEXT NOT NULL,
                    conditions TEXT,
                    time_constraints TEXT,
                    location_constraints TEXT,
                    purpose_limitation TEXT,
                    created_at REAL NOT NULL,
                    expires_at REAL,
                    created_by TEXT NOT NULL,
                    approval_required BOOLEAN,
                    approval_status TEXT
                )
            ''')

            conn.execute('''
                CREATE INDEX IF NOT EXISTS idx_subject ON access_policies(subject_type, subject_id)
            ''')
            conn.execute('''
                CREATE INDEX IF NOT EXISTS idx_resource ON access_policies(resource_pattern)
            ''')

        # Access Requests database
        requests_db = self.storage_path / "access_requests.db"
        with sqlite3.connect(requests_db) as conn:
            conn.execute('''
                CREATE TABLE IF NOT EXISTS access_requests (
                    request_id TEXT PRIMARY KEY,
                    user_id TEXT NOT NULL,
                    asset_id TEXT NOT NULL,
                    access_level TEXT NOT NULL,
                    purpose TEXT NOT NULL,
                    justification TEXT,
                    requested_at REAL NOT NULL,
                    expires_at REAL,
                    status TEXT NOT NULL,
                    approver_id TEXT,
                    approved_at REAL,
                    conditions TEXT,
                    session_id TEXT
                )
            ''')

            conn.execute('''
                CREATE INDEX IF NOT EXISTS idx_user_requests ON access_requests(user_id)
            ''')
            conn.execute('''
                CREATE INDEX IF NOT EXISTS idx_asset_requests ON access_requests(asset_id)
            ''')
            conn.execute('''
                CREATE INDEX IF NOT EXISTS idx_status ON access_requests(status)
            ''')

"""Register new CDI asset for protection."""
def register_cdi_asset(self, name: str, description: str,
                          classification: CDIClassification, owner: str,
                          data_type: str, file_path: Optional[str] = None,
                          sensitivity_markers: Optional[List[str]] = None,
                          retention_period: int = 2555,  # 7 years default
                          protection_requirements: Optional[Dict[str, Any]] = None,
                          metadata: Optional[Dict[str, Any]] = None) -> str:
        """Register new CDI asset for protection."""
        asset_id = f"cdi_{uuid.uuid4().hex[:16]}"
        current_time = time.time()

        asset = CDIAsset(
            asset_id=asset_id,
            name=name,
            description=description,
            classification=classification,
            owner=owner,
            created_at=current_time,
            updated_at=current_time,
            file_path=file_path,
            data_type=data_type,
            sensitivity_markers=sensitivity_markers or [],
            retention_period=retention_period,
            destruction_date=None,
            access_history=[],
            protection_requirements=protection_requirements or self._default_protection_requirements(classification),
            metadata=metadata or {}
        )

        # Store asset
        self.cdi_assets[asset_id] = asset
        self._persist_cdi_asset(asset)

        # Generate protection key
        if asset.protection_requirements.get("encryption_required", True):
            self._generate_asset_protection_key(asset_id, classification)

        # Apply default protection
        if file_path:
            asyncio.create_task(self._apply_data_protection(asset_id, DataState.AT_REST))

        # Log asset registration
        self.audit_manager.log_audit_event(
            event_type=AuditEventType.DATA_CLASSIFICATION_CHANGE,
            severity=SeverityLevel.INFO,
            action="cdi_asset_registered",
            description=f"CDI asset registered: {name}",
            user_id=owner,
            resource=asset_id,
            details={
                "asset_name": name,
                "classification": classification.value,
                "data_type": data_type,
                "protection_requirements": asset.protection_requirements
            }
        )

        logger.info(f"Registered CDI asset: {asset_id} ({name})")
        return asset_id

"""Get default protection requirements for classification level."""
def _default_protection_requirements(self, classification: CDIClassification) -> Dict[str, Any]:
        """Get default protection requirements for classification level."""
        base_requirements = {
            "encryption_required": True,
            "access_logging": True,
            "backup_encrypted": True,
            "transmission_encrypted": True,
            "storage_encrypted": True
        }

        if classification in [CDIClassification.DFARS_COVERED, CDIClassification.EXPORT_CONTROLLED]:
            base_requirements.update({
                "fips_compliance": True,
                "key_escrow": True,
                "access_approval_required": True,
                "periodic_access_review": True,
                "data_loss_prevention": True,
                "watermarking": True,
                "screen_capture_prevention": True,
                "print_restrictions": True
            })

        return base_requirements

"""Persist CDI asset to database."""
def _persist_cdi_asset(self, asset: CDIAsset):
        """Persist CDI asset to database."""
        assets_db = self.storage_path / "cdi_assets.db"
        with sqlite3.connect(assets_db) as conn:
            conn.execute('''
                INSERT OR REPLACE INTO cdi_assets (
                    asset_id, name, description, classification, owner,
                    created_at, updated_at, file_path, data_type,
                    sensitivity_markers, retention_period, destruction_date,
                    access_history, protection_requirements, metadata
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                asset.asset_id, asset.name, asset.description,
                asset.classification.value, asset.owner,
                asset.created_at, asset.updated_at, asset.file_path,
                asset.data_type, json.dumps(asset.sensitivity_markers),
                asset.retention_period, asset.destruction_date,
                json.dumps(asset.access_history),
                json.dumps(asset.protection_requirements),
                json.dumps(asset.metadata)
            ))

"""Generate protection key for CDI asset."""
def _generate_asset_protection_key(self, asset_id: str, classification: CDIClassification):
        """Generate protection key for CDI asset."""
        # Use stronger key for higher classifications
        key_size = "AES-256-GCM"
        if classification in [CDIClassification.DFARS_COVERED, CDIClassification.EXPORT_CONTROLLED]:
            key_size = "AES-256-GCM"  # Could use even stronger if available

        key, key_id = self.crypto_module.generate_symmetric_key(key_size)
        self.protection_keys[asset_id] = key

        # Schedule key rotation based on classification
        rotation_interval = self._get_key_rotation_interval(classification)
        self.key_rotation_schedule[asset_id] = time.time() + rotation_interval

        # Store key securely (in production, use HSM or key management service)
        key_file = self.storage_path / "keys" / f"{asset_id}.key"
        key_file.parent.mkdir(exist_ok=True)

        with open(key_file, 'wb') as f:
            f.write(key)

        key_file.chmod(0o600)  # Restrict permissions

"""Get key rotation interval based on classification."""
def _get_key_rotation_interval(self, classification: CDIClassification) -> int:
        """Get key rotation interval based on classification."""
        intervals = {
            CDIClassification.CONTROLLED_UNCLASSIFIED: 365 * 24 * 3600,  # 1 year
            CDIClassification.BASIC_CUI: 180 * 24 * 3600,  # 6 months
            CDIClassification.SPECIFIED_CUI: 90 * 24 * 3600,  # 3 months
            CDIClassification.DFARS_COVERED: 30 * 24 * 3600,  # 1 month
            CDIClassification.EXPORT_CONTROLLED: 30 * 24 * 3600  # 1 month
        }
        return intervals.get(classification, 90 * 24 * 3600)

"""Create access control policy for CDI resources."""
def create_access_policy(self, name: str, description: str,
                           subject_type: str, subject_id: str,
                           resource_pattern: str, access_level: AccessLevel,
                           created_by: str, conditions: Optional[Dict[str, Any]] = None,
                           time_constraints: Optional[Dict[str, Any]] = None,
                           location_constraints: Optional[List[str]] = None,
                           purpose_limitation: Optional[str] = None,
                           expires_at: Optional[float] = None,
                           approval_required: bool = False) -> str:
        """Create access control policy for CDI resources."""
        policy_id = f"policy_{uuid.uuid4().hex[:16]}"

        policy = AccessPolicy(
            policy_id=policy_id,
            name=name,
            description=description,
            subject_type=subject_type,
            subject_id=subject_id,
            resource_pattern=resource_pattern,
            access_level=access_level,
            conditions=conditions or {},
            time_constraints=time_constraints,
            location_constraints=location_constraints,
            purpose_limitation=purpose_limitation,
            created_at=time.time(),
            expires_at=expires_at,
            created_by=created_by,
            approval_required=approval_required,
            approval_status="active" if not approval_required else "pending"
        )

        self.access_policies[policy_id] = policy
        self._persist_access_policy(policy)

        # Log policy creation
        self.audit_manager.log_audit_event(
            event_type=AuditEventType.AUTHORIZATION,
            severity=SeverityLevel.INFO,
            action="access_policy_created",
            description=f"Access policy created: {name}",
            user_id=created_by,
            resource=resource_pattern,
            details={
                "policy_id": policy_id,
                "subject_type": subject_type,
                "subject_id": subject_id,
                "access_level": access_level.value,
                "approval_required": approval_required
            }
        )

        logger.info(f"Created access policy: {policy_id} ({name})")
        return policy_id

"""Persist access policy to database."""
def _persist_access_policy(self, policy: AccessPolicy):
        """Persist access policy to database."""
        policies_db = self.storage_path / "access_policies.db"
        with sqlite3.connect(policies_db) as conn:
            conn.execute('''
                INSERT OR REPLACE INTO access_policies (
                    policy_id, name, description, subject_type, subject_id,
                    resource_pattern, access_level, conditions, time_constraints,
                    location_constraints, purpose_limitation, created_at,
                    expires_at, created_by, approval_required, approval_status
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                policy.policy_id, policy.name, policy.description,
                policy.subject_type, policy.subject_id, policy.resource_pattern,
                policy.access_level.value, json.dumps(policy.conditions),
                json.dumps(policy.time_constraints),
                json.dumps(policy.location_constraints),
                policy.purpose_limitation, policy.created_at,
                policy.expires_at, policy.created_by,
                policy.approval_required, policy.approval_status
            ))

"""Request access to CDI asset."""
def request_data_access(self, user_id: str, asset_id: str,
                          access_level: AccessLevel, purpose: str,
                          justification: str, expires_at: Optional[float] = None,
                          session_id: Optional[str] = None) -> str:
        """Request access to CDI asset."""
        request_id = f"req_{uuid.uuid4().hex[:16]}"

        # Check if asset exists
        if asset_id not in self.cdi_assets:
            raise ValueError(f"CDI asset {asset_id} not found")

        asset = self.cdi_assets[asset_id]

        # Determine if approval is required
        approval_required = self._is_approval_required(user_id, asset, access_level)

        request = DataAccessRequest(
            request_id=request_id,
            user_id=user_id,
            asset_id=asset_id,
            access_level=access_level,
            purpose=purpose,
            justification=justification,
            requested_at=time.time(),
            expires_at=expires_at,
            status="pending_approval" if approval_required else "auto_approved",
            approver_id=None,
            approved_at=None if approval_required else time.time(),
            conditions={},
            session_id=session_id
        )

        self.access_requests[request_id] = request
        self._persist_access_request(request)

        # Log access request
        self.audit_manager.log_audit_event(
            event_type=AuditEventType.ACCESS_GRANTED if not approval_required else AuditEventType.AUTHORIZATION,
            severity=SeverityLevel.INFO,
            action="data_access_requested",
            description=f"Data access requested for CDI asset {asset.name}",
            user_id=user_id,
            session_id=session_id,
            resource=asset_id,
            details={
                "request_id": request_id,
                "access_level": access_level.value,
                "purpose": purpose,
                "approval_required": approval_required,
                "classification": asset.classification.value
            }
        )

        # Auto-approve if no approval required
        if not approval_required:
            self._auto_approve_request(request)

        logger.info(f"Data access requested: {request_id} for asset {asset_id}")
        return request_id

"""Determine if approval is required for access request."""
def _is_approval_required(self, user_id: str, asset: CDIAsset, access_level: AccessLevel) -> bool:
        """Determine if approval is required for access request."""
        # High-value classifications require approval
        if asset.classification in [CDIClassification.DFARS_COVERED, CDIClassification.EXPORT_CONTROLLED]:
            return True

        # Write/modify/delete access requires approval
        if access_level in [AccessLevel.WRITE, AccessLevel.MODIFY, AccessLevel.DELETE, AccessLevel.FULL_CONTROL]:
            return True

        # Check asset-specific requirements
        if asset.protection_requirements.get("access_approval_required", False):
            return True

        # Check user-specific policies
        return self._check_user_approval_requirements(user_id, asset.asset_id)

"""Persist access request to database."""
def _persist_access_request(self, request: DataAccessRequest):
        """Persist access request to database."""
        requests_db = self.storage_path / "access_requests.db"
        with sqlite3.connect(requests_db) as conn:
            conn.execute('''
                INSERT OR REPLACE INTO access_requests (
                    request_id, user_id, asset_id, access_level, purpose,
                    justification, requested_at, expires_at, status,
                    approver_id, approved_at, conditions, session_id
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                request.request_id, request.user_id, request.asset_id,
                request.access_level.value, request.purpose,
                request.justification, request.requested_at,
                request.expires_at, request.status,
                request.approver_id, request.approved_at,
                json.dumps(request.conditions), request.session_id
            ))

"""Auto-approve access request."""
def _auto_approve_request(self, request: DataAccessRequest):
        """Auto-approve access request."""
        request.status = "approved"
        request.approved_at = time.time()
        request.approver_id = "system"

        # Add to access cache
        cache_key = f"{request.user_id}:{request.asset_id}"
        self.access_cache[cache_key] = {
            "access_level": request.access_level,
            "approved_at": request.approved_at,
            "expires_at": request.expires_at,
            "conditions": request.conditions
        }

"""Approve pending access request."""
def approve_access_request(self, request_id: str, approver_id: str,
                             conditions: Optional[Dict[str, Any]] = None) -> bool:
        """Approve pending access request."""
        if request_id not in self.access_requests:
            raise ValueError(f"Access request {request_id} not found")

        request = self.access_requests[request_id]

        if request.status != "pending_approval":
            raise ValueError(f"Request {request_id} is not pending approval")

        # Update request
        request.status = "approved"
        request.approver_id = approver_id
        request.approved_at = time.time()
        request.conditions = conditions or {}

        self._persist_access_request(request)

        # Add to access cache
        cache_key = f"{request.user_id}:{request.asset_id}"
        self.access_cache[cache_key] = {
            "access_level": request.access_level,
            "approved_at": request.approved_at,
            "expires_at": request.expires_at,
            "conditions": request.conditions
        }

        # Log approval
        asset = self.cdi_assets[request.asset_id]
        self.audit_manager.log_audit_event(
            event_type=AuditEventType.ACCESS_GRANTED,
            severity=SeverityLevel.INFO,
            action="data_access_approved",
            description=f"Data access approved for CDI asset {asset.name}",
            user_id=approver_id,
            resource=request.asset_id,
            details={
                "request_id": request_id,
                "user_id": request.user_id,
                "access_level": request.access_level.value,
                "conditions": request.conditions
            }
        )

        logger.info(f"Access request approved: {request_id} by {approver_id}")
        return True

"""Check if granted access level is sufficient for required level."""
def _access_level_sufficient(self, granted_level: AccessLevel, required_level: AccessLevel) -> bool:
        """Check if granted access level is sufficient for required level."""
        level_hierarchy = {
            AccessLevel.NONE: 0,
            AccessLevel.READ: 1,
            AccessLevel.WRITE: 2,
            AccessLevel.MODIFY: 3,
            AccessLevel.DELETE: 4,
            AccessLevel.ADMIN: 5,
            AccessLevel.FULL_CONTROL: 6
        }

        return level_hierarchy.get(granted_level, 0) >= level_hierarchy.get(required_level, 0)

"""Get policies applicable to user and asset."""
def _get_applicable_policies(self, user_id: str, asset_id: str) -> List[AccessPolicy]:
        """Get policies applicable to user and asset."""
        applicable = []

        for policy in self.access_policies.values():
            # Check if policy applies to this user
            if policy.subject_type == "user" and policy.subject_id == user_id:
                # Check if policy applies to this asset
                if self._resource_pattern_matches(policy.resource_pattern, asset_id):
                    # Check if policy is still valid
                    if not policy.expires_at or time.time() < policy.expires_at:
                        applicable.append(policy)

        return applicable

"""Check if resource pattern matches asset ID."""
def _resource_pattern_matches(self, pattern: str, asset_id: str) -> bool:
        """Check if resource pattern matches asset ID."""
        # Simple pattern matching - could be enhanced with regex
        if pattern == "*":
            return True
        if pattern == asset_id:
            return True
        # Pattern matching for prefixes
        if pattern.endswith("*") and asset_id.startswith(pattern[:-1]):
            return True
        return False

"""Check if policy grants requested access level."""
def _policy_grants_access(self, policy: AccessPolicy, requested_level: AccessLevel,
                            context: Optional[Dict[str, Any]] = None) -> bool:
        """Check if policy grants requested access level."""
        # Check access level
        if not self._access_level_sufficient(policy.access_level, requested_level):
            return False

        # Check time constraints
        if policy.time_constraints:
            current_time = datetime.now()
            if not self._time_constraints_met(policy.time_constraints, current_time):
                return False

        # Check location constraints
        if policy.location_constraints and context:
            user_location = context.get("location")
            if user_location and user_location not in policy.location_constraints:
                return False

        # Check other conditions
        if policy.conditions and context:
            if not self._conditions_met(policy.conditions, context):
                return False

        return True

"""Check if time constraints are met."""
def _time_constraints_met(self, constraints: Dict[str, Any], current_time: datetime) -> bool:
        """Check if time constraints are met."""
        # Simple time constraint checking
        if "allowed_hours" in constraints:
            current_hour = current_time.hour
            allowed_hours = constraints["allowed_hours"]
            if current_hour not in allowed_hours:
                return False

        if "allowed_days" in constraints:
            current_day = current_time.weekday()  # 0=Monday
            allowed_days = constraints["allowed_days"]
            if current_day not in allowed_days:
                return False

        return True

"""Check if policy conditions are met."""
def _conditions_met(self, conditions: Dict[str, Any], context: Dict[str, Any]) -> bool:
        """Check if policy conditions are met."""
        # Simple condition checking - could be enhanced
        for key, required_value in conditions.items():
            if context.get(key) != required_value:
                return False
        return True

"""Log CDI asset access attempt."""
def _log_asset_access(self, user_id: str, asset: CDIAsset, access_level: AccessLevel,
                         session_id: Optional[str], outcome: str):
        """Log CDI asset access attempt."""
        # Add to asset access history
        access_record = {
            "timestamp": time.time(),
            "user_id": user_id,
            "session_id": session_id,
            "access_level": access_level.value,
            "outcome": outcome
        }
        asset.access_history.append(access_record)

        # Keep only recent access history
        if len(asset.access_history) > 1000:
            asset.access_history = asset.access_history[-1000:]

        self._persist_cdi_asset(asset)

        # Log to audit trail
        event_type = AuditEventType.ACCESS_GRANTED if outcome == "granted" else AuditEventType.ACCESS_DENIED
        severity = SeverityLevel.WARNING if outcome == "denied" else SeverityLevel.INFO

        self.audit_manager.log_audit_event(
            event_type=event_type,
            severity=severity,
            action=f"cdi_access_{outcome}",
            description=f"CDI asset access {outcome}: {asset.name}",
            user_id=user_id,
            session_id=session_id,
            resource=asset.asset_id,
            details={
                "asset_name": asset.name,
                "classification": asset.classification.value,
                "access_level": access_level.value,
                "outcome": outcome
            }
        )

"""Get CDI asset inventory."""
def get_cdi_inventory(self, classification_filter: Optional[CDIClassification] = None,
                         owner_filter: Optional[str] = None) -> List[Dict[str, Any]]:
        """Get CDI asset inventory."""
        inventory = []

        for asset in self.cdi_assets.values():
            if classification_filter and asset.classification != classification_filter:
                continue
            if owner_filter and asset.owner != owner_filter:
                continue

            inventory.append({
                "asset_id": asset.asset_id,
                "name": asset.name,
                "description": asset.description,
                "classification": asset.classification.value,
                "owner": asset.owner,
                "data_type": asset.data_type,
                "created_at": asset.created_at,
                "updated_at": asset.updated_at,
                "retention_period": asset.retention_period,
                "protection_status": "encrypted" if asset.asset_id in self.protection_keys else "unprotected",
                "access_history_count": len(asset.access_history),
                "sensitivity_markers": asset.sensitivity_markers
            })

        return inventory

"""Generate CDI access report."""
def get_access_report(self, days: int = 30) -> Dict[str, Any]:
        """Generate CDI access report."""
        cutoff_time = time.time() - (days * 24 * 3600)

        report = {
            "report_period_days": days,
            "total_assets": len(self.cdi_assets),
            "assets_by_classification": {},
            "access_requests": {
                "total": len(self.access_requests),
                "pending": 0,
                "approved": 0,
                "denied": 0,
                "expired": 0
            },
            "recent_access": [],
            "top_accessed_assets": [],
            "security_events": 0
        }

        # Count assets by classification
        for asset in self.cdi_assets.values():
            classification = asset.classification.value
            report["assets_by_classification"][classification] = \
                report["assets_by_classification"].get(classification, 0) + 1

        # Count access requests by status
        for request in self.access_requests.values():
            if request.requested_at >= cutoff_time:
                report["access_requests"][request.status] = \
                    report["access_requests"].get(request.status, 0) + 1

        # Collect recent access events
        for asset in self.cdi_assets.values():
            for access_record in asset.access_history:
                if access_record["timestamp"] >= cutoff_time:
                    report["recent_access"].append({
                        "asset_id": asset.asset_id,
                        "asset_name": asset.name,
                        "classification": asset.classification.value,
                        "user_id": access_record["user_id"],
                        "access_level": access_record["access_level"],
                        "timestamp": access_record["timestamp"],
                        "outcome": access_record["outcome"]
                    })

        return report

"""Create CDI protection framework."""
def create_cdi_protection_framework(storage_path: str = ".claude/.artifacts/cdi_protection") -> CDIProtectionFramework:
    """Create CDI protection framework."""
    return CDIProtectionFramework(storage_path)

