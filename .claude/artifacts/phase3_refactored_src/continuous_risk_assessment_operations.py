"""
Extracted operations service from continuous_risk_assessment

Automatically generated by God Object Decomposer
"""

import time
from dataclasses import dataclass
import sys
import hashlib
from lib.shared.utilities import get_logger
import os
from typing import Dict, List, Optional, Any
import json


"""Initialize DFARS continuous risk assessment system."""
def __init__(self, config_path: Optional[str] = None):
        """Initialize DFARS continuous risk assessment system."""
        self.config = self._load_config(config_path)
        self.threat_indicators: Dict[str, ThreatIndicator] = {}
        self.vulnerabilities: Dict[str, VulnerabilityAssessment] = {}
        self.risk_history: List[RiskAssessment] = []
        self.asset_inventory: Dict[str, Dict[str, Any]] = {}

        # Threat intelligence feeds
        self.threat_feeds: Dict[str, Dict[str, Any]] = {}
        self.feed_last_update: Dict[str, float] = {}

        # Risk calculation components
        self.risk_metrics: Dict[str, deque] = defaultdict(lambda: deque(maxlen=1000))
        self.baseline_metrics: Dict[str, float] = {}

        # Initialize components
        self.audit_manager = DFARSAuditTrailManager(".claude/.artifacts/risk_audit")
        self.incident_response = DFARSIncidentResponseSystem()

        # Initialize storage
        self.storage_path = Path(".claude/.artifacts/risk_assessment")
        self.storage_path.mkdir(parents=True, exist_ok=True)

        # Load existing data
        self._load_existing_data()

        # Initialize threat intelligence feeds
        self._initialize_threat_feeds()

        # Start background tasks
        self.active_monitoring = False

        logger.info("DFARS Continuous Risk Assessment System initialized")

"""Initialize threat intelligence feeds."""
def _initialize_threat_feeds(self):
        """Initialize threat intelligence feeds."""
        if not self.config["risk_assessment"]["threat_intelligence"]["feeds_enabled"]:
            return

        # Government feeds
        gov_feeds = self.config["risk_assessment"]["threat_intelligence"]["government_feeds"]
        for feed in gov_feeds:
            self.threat_feeds[feed] = {
                "type": "government",
                "url": self._get_feed_url(feed),
                "api_key": None,  # Government feeds typically don't require API keys
                "last_update": 0,
                "update_interval": 3600,
                "active": True
            }

        # Commercial feeds (would be configured with API keys)
        commercial_feeds = self.config["risk_assessment"]["threat_intelligence"]["commercial_feeds"]
        for feed in commercial_feeds:
            self.threat_feeds[feed] = {
                "type": "commercial",
                "url": self._get_feed_url(feed),
                "api_key": self._get_api_key(feed),
                "last_update": 0,
                "update_interval": 1800,  # More frequent updates for commercial feeds
                "active": True
            }

        # Internal feeds
        if self.config["risk_assessment"]["threat_intelligence"]["internal_feeds"]:
            self.threat_feeds["internal"] = {
                "type": "internal",
                "url": "internal://threat_intelligence",
                "api_key": None,
                "last_update": 0,
                "update_interval": 300,  # 5 minutes for internal feeds
                "active": True
            }

        logger.info(f"Initialized {len(self.threat_feeds)} threat intelligence feeds")

"""Get URL for threat intelligence feed."""
def _get_feed_url(self, feed_name: str) -> str:
        """Get URL for threat intelligence feed."""
        feed_urls = {
            "cisa": "https://www.cisa.gov/cybersecurity-advisories/json",
            "cert": "https://kb.cert.org/vuls/json",
            "nvd": "https://services.nvd.nist.gov/rest/json/cves/2.0"
        }
        return feed_urls.get(feed_name, "")

"""Get API key for commercial threat intelligence feed."""
def _get_api_key(self, feed_name: str) -> Optional[str]:
        """Get API key for commercial threat intelligence feed."""
        # In production, this would retrieve API keys from secure storage
        return None

"""Create threat indicator from raw data."""
def _create_threat_indicator(self, indicator_data: Dict[str, Any], source: str) -> Optional[ThreatIndicator]:
        """Create threat indicator from raw data."""
        try:
            indicator_id = hashlib.sha256(
                f"{indicator_data['type']}:{indicator_data['value']}:{source}".encode()
            ).hexdigest()[:16]

            return ThreatIndicator(
                indicator_id=indicator_id,
                indicator_type=indicator_data["type"],
                indicator_value=indicator_data["value"],
                threat_category=ThreatCategory(indicator_data["category"]),
                confidence_score=indicator_data["confidence"],
                severity=RiskLevel(indicator_data["severity"]),
                first_seen=time.time(),
                last_seen=time.time(),
                source=source,
                context=indicator_data.get("context", {}),
                ttl=indicator_data.get("ttl")
            )

        except Exception as e:
            logger.error(f"Failed to create threat indicator: {e}")
            return None

"""Create vulnerability assessment from scan data."""
def _create_vulnerability_assessment(self, vuln_data: Dict[str, Any]) -> Optional[VulnerabilityAssessment]:
        """Create vulnerability assessment from scan data."""
        try:
            vulnerability_id = vuln_data.get("cve_id", f"VULN-{int(time.time())}")

            # Determine risk level based on CVSS score
            cvss_score = vuln_data["cvss_score"]
            if cvss_score >= 9.0:
                risk_level = RiskLevel.CRITICAL
                remediation_priority = 1
            elif cvss_score >= 7.0:
                risk_level = RiskLevel.HIGH
                remediation_priority = 2
            elif cvss_score >= 4.0:
                risk_level = RiskLevel.MEDIUM
                remediation_priority = 3
            else:
                risk_level = RiskLevel.LOW
                remediation_priority = 4

            return VulnerabilityAssessment(
                vulnerability_id=vulnerability_id,
                cve_id=vuln_data.get("cve_id"),
                title=vuln_data["title"],
                description=vuln_data["description"],
                affected_systems=vuln_data["affected_systems"],
                cvss_score=cvss_score,
                risk_level=risk_level,
                exploit_available=vuln_data["exploit_available"],
                patch_available=vuln_data["patch_available"],
                discovered_at=time.time(),
                source=VulnerabilitySource(vuln_data["source"]),
                remediation_priority=remediation_priority,
                business_impact=self._assess_business_impact(vuln_data["affected_systems"], cvss_score),
                technical_impact=self._assess_technical_impact(cvss_score, vuln_data["exploit_available"])
            )

        except Exception as e:
            logger.error(f"Failed to create vulnerability assessment: {e}")
            return None

"""Assess business impact of vulnerability."""
def _assess_business_impact(self, affected_systems: List[str], cvss_score: float) -> str:
        """Assess business impact of vulnerability."""
        # Simplified business impact assessment
        critical_systems = ["database", "authentication", "payment"]

        has_critical_system = any(sys in affected_systems[0] for sys in critical_systems)

        if cvss_score >= 7.0 and has_critical_system:
            return "High - Critical systems affected with significant vulnerability"
        elif cvss_score >= 7.0 or has_critical_system:
            return "Medium - Either high CVSS score or critical system affected"
        else:
            return "Low - Limited business impact expected"

"""Assess technical impact of vulnerability."""
def _assess_technical_impact(self, cvss_score: float, exploit_available: bool) -> str:
        """Assess technical impact of vulnerability."""
        if cvss_score >= 9.0:
            impact = "Critical technical impact"
        elif cvss_score >= 7.0:
            impact = "High technical impact"
        elif cvss_score >= 4.0:
            impact = "Medium technical impact"
        else:
            impact = "Low technical impact"

        if exploit_available:
            impact += " with available exploit"

        return impact

"""Calculate current threat landscape."""
def _calculate_threat_landscape(self) -> Dict[ThreatCategory, float]:
        """Calculate current threat landscape."""
        threat_scores = {}

        for category in ThreatCategory:
            category_indicators = [
                indicator for indicator in self.threat_indicators.values()
                if indicator.threat_category == category
            ]

            if category_indicators:
                # Calculate weighted average based on confidence and recency
                total_score = 0.0
                total_weight = 0.0

                current_time = time.time()
                for indicator in category_indicators:
                    age_factor = max(0.1, 1.0 - ((current_time - indicator.last_seen) / 86400))  # Decay over 24 hours
                    weight = indicator.confidence_score * age_factor

                    severity_scores = {
                        RiskLevel.VERY_LOW: 0.1, RiskLevel.LOW: 0.3,
                        RiskLevel.MEDIUM: 0.5, RiskLevel.HIGH: 0.8,
                        RiskLevel.CRITICAL: 1.0
                    }

                    score = severity_scores.get(indicator.severity, 0.5)
                    total_score += score * weight
                    total_weight += weight

                threat_scores[category] = total_score / total_weight if total_weight > 0 else 0.0
            else:
                threat_scores[category] = 0.0

        return threat_scores

"""Calculate vulnerability summary statistics."""
def _calculate_vulnerability_summary(self) -> Dict[str, int]:
        """Calculate vulnerability summary statistics."""
        summary = {
            "total": len(self.vulnerabilities),
            "critical": 0,
            "high": 0,
            "medium": 0,
            "low": 0,
            "with_exploits": 0,
            "patchable": 0
        }

        for vulnerability in self.vulnerabilities.values():
            if vulnerability.risk_level == RiskLevel.CRITICAL:
                summary["critical"] += 1
            elif vulnerability.risk_level == RiskLevel.HIGH:
                summary["high"] += 1
            elif vulnerability.risk_level == RiskLevel.MEDIUM:
                summary["medium"] += 1
            else:
                summary["low"] += 1

            if vulnerability.exploit_available:
                summary["with_exploits"] += 1

            if vulnerability.patch_available:
                summary["patchable"] += 1

        return summary

"""Calculate overall organizational risk score."""
def _calculate_overall_risk_score(self, threat_landscape: Dict[ThreatCategory, float],
                                    vulnerability_summary: Dict[str, int],
                                    asset_risk_scores: Dict[str, float]) -> float:
        """Calculate overall organizational risk score."""
        # Threat landscape component (30% weight)
        threat_score = sum(threat_landscape.values()) / len(threat_landscape) if threat_landscape else 0.0
        threat_component = threat_score * 0.3

        # Vulnerability component (40% weight)
        total_vulns = vulnerability_summary["total"]
        if total_vulns > 0:
            critical_weight = vulnerability_summary["critical"] * 1.0
            high_weight = vulnerability_summary["high"] * 0.8
            medium_weight = vulnerability_summary["medium"] * 0.5
            low_weight = vulnerability_summary["low"] * 0.2

            vuln_score = (critical_weight + high_weight + medium_weight + low_weight) / total_vulns
        else:
            vuln_score = 0.0

        vuln_component = vuln_score * 0.4

        # Asset risk component (30% weight)
        asset_score = sum(asset_risk_scores.values()) / len(asset_risk_scores) if asset_risk_scores else 0.0
        asset_component = asset_score * 0.3

        overall_score = threat_component + vuln_component + asset_component
        return min(overall_score, 1.0)

"""Determine risk level from overall risk score."""
def _determine_risk_level(self, risk_score: float) -> RiskLevel:
        """Determine risk level from overall risk score."""
        thresholds = self.config["risk_assessment"]["risk_thresholds"]

        if risk_score >= thresholds["critical"]:
            return RiskLevel.CRITICAL
        elif risk_score >= thresholds["high"]:
            return RiskLevel.HIGH
        elif risk_score >= thresholds["medium"]:
            return RiskLevel.MEDIUM
        elif risk_score >= thresholds["low"]:
            return RiskLevel.LOW
        else:
            return RiskLevel.VERY_LOW

"""Calculate risk trends over time."""
def _calculate_risk_trends(self) -> Dict[str, float]:
        """Calculate risk trends over time."""
        trends = {}

        if len(self.risk_history) >= 2:
            current_assessment = self.risk_history[-1]
            previous_assessment = self.risk_history[-2]

            # Overall risk trend
            trends["overall_risk"] = (
                current_assessment.overall_risk_score - previous_assessment.overall_risk_score
            )

            # Threat landscape trends
            for category in ThreatCategory:
                current_score = current_assessment.threat_landscape.get(category, 0.0)
                previous_score = previous_assessment.threat_landscape.get(category, 0.0)
                trends[f"threat_{category.value}"] = current_score - previous_score

        return trends

"""Generate risk mitigation recommendations."""
def _generate_risk_recommendations(self, threat_landscape: Dict[ThreatCategory, float],
                                     vulnerability_summary: Dict[str, int],
                                     asset_risk_scores: Dict[str, float]) -> List[str]:
        """Generate risk mitigation recommendations."""
        recommendations = []

        # Threat-based recommendations
        high_threat_categories = [
            category for category, score in threat_landscape.items()
            if score >= 0.7
        ]

        for category in high_threat_categories:
            if category == ThreatCategory.MALWARE:
                recommendations.append("Enhance malware protection and endpoint detection capabilities")
            elif category == ThreatCategory.ADVANCED_PERSISTENT_THREAT:
                recommendations.append("Implement advanced threat hunting and behavioral analysis")
            elif category == ThreatCategory.INSIDER_THREAT:
                recommendations.append("Strengthen insider threat monitoring and access controls")

        # Vulnerability-based recommendations
        if vulnerability_summary["critical"] > 0:
            recommendations.append(f"Immediately patch {vulnerability_summary['critical']} critical vulnerabilities")

        if vulnerability_summary["with_exploits"] > 0:
            recommendations.append("Prioritize patching vulnerabilities with available exploits")

        # Asset-based recommendations
        high_risk_assets = [
            asset_id for asset_id, risk_score in asset_risk_scores.items()
            if risk_score >= 0.8
        ]

        if high_risk_assets:
            recommendations.append(f"Review security controls for {len(high_risk_assets)} high-risk assets")

        return recommendations

"""Identify current mitigating security controls."""
def _identify_mitigating_controls(self) -> List[str]:
        """Identify current mitigating security controls."""
        # This would integrate with security control inventory in production
        return [
            "Multi-factor authentication",
            "Network segmentation",
            "Endpoint detection and response",
            "Security awareness training",
            "Incident response plan",
            "Regular vulnerability scanning",
            "Log monitoring and SIEM"
        ]

"""Calculate residual risks after considering mitigating controls."""
def _calculate_residual_risks(self, threat_landscape: Dict[ThreatCategory, float],
                                vulnerability_summary: Dict[str, int],
                                mitigating_controls: List[str]) -> List[Dict[str, Any]]:
        """Calculate residual risks after considering mitigating controls."""
        residual_risks = []

        # Calculate control effectiveness (simplified)
        control_coverage = len(mitigating_controls) / 10.0  # Assume 10 is full coverage
        control_effectiveness = min(control_coverage, 0.9)  # Max 90% effectiveness

        # Calculate residual risk for each threat category
        for category, risk_score in threat_landscape.items():
            residual_score = risk_score * (1.0 - control_effectiveness)

            if residual_score >= 0.3:  # Only include significant residual risks
                residual_risks.append({
                    "category": category.value,
                    "residual_score": residual_score,
                    "original_score": risk_score,
                    "control_effectiveness": control_effectiveness,
                    "description": f"Residual {category.value} risk after controls"
                })

        return residual_risks

"""Persist risk assessment to storage."""
def _persist_risk_assessment(self, assessment: RiskAssessment):
        """Persist risk assessment to storage."""
        assessment_file = self.storage_path / f"assessment_{assessment.assessment_id}.json"

        with open(assessment_file, 'w') as f:
            assessment_dict = asdict(assessment)
            assessment_dict['risk_level'] = assessment.risk_level.value

            # Convert ThreatCategory keys to strings for JSON serialization
            assessment_dict['threat_landscape'] = {
                category.value: score for category, score in assessment.threat_landscape.items()
            }

            json.dump(assessment_dict, f, indent=2)

"""Update risk trend metrics."""
def _update_risk_trends(self, risk_assessment: RiskAssessment):
        """Update risk trend metrics."""
        # Update risk metrics time series
        self.risk_metrics["overall_risk"].append(risk_assessment.overall_risk_score)

        for category, score in risk_assessment.threat_landscape.items():
            self.risk_metrics[f"threat_{category.value}"].append(score)

        # Update baseline metrics (30-day rolling average)
        if len(self.risk_metrics["overall_risk"]) >= 30:
            self.baseline_metrics["overall_risk"] = np.mean(list(self.risk_metrics["overall_risk"]))

"""Stop continuous risk assessment monitoring."""
def stop_continuous_assessment(self):
        """Stop continuous risk assessment monitoring."""
        self.active_monitoring = False
        logger.info("Stopped continuous risk assessment monitoring")

"""Get data for risk assessment dashboard."""
def get_risk_dashboard_data(self) -> Dict[str, Any]:
        """Get data for risk assessment dashboard."""
        latest_assessment = self.risk_history[-1] if self.risk_history else None

        if not latest_assessment:
            return {"error": "No risk assessments available"}

        return {
            "current_risk": {
                "overall_score": latest_assessment.overall_risk_score,
                "risk_level": latest_assessment.risk_level.value,
                "assessment_time": latest_assessment.timestamp
            },
            "threat_landscape": {
                category.value: score
                for category, score in latest_assessment.threat_landscape.items()
            },
            "vulnerability_summary": latest_assessment.vulnerability_summary,
            "asset_summary": {
                "total_assets": len(latest_assessment.asset_risk_scores),
                "high_risk_assets": len([
                    score for score in latest_assessment.asset_risk_scores.values()
                    if score >= 0.8
                ]),
                "average_risk": (
                    sum(latest_assessment.asset_risk_scores.values()) /
                    len(latest_assessment.asset_risk_scores)
                ) if latest_assessment.asset_risk_scores else 0.0
            },
            "trends": latest_assessment.risk_trends,
            "recommendations": latest_assessment.recommendations[:5],  # Top 5
            "residual_risks": len(latest_assessment.residual_risks),
            "threat_indicators": {
                "total": len(self.threat_indicators),
                "high_confidence": len([
                    ind for ind in self.threat_indicators.values()
                    if ind.confidence_score >= 0.8
                ]),
                "recent": len([
                    ind for ind in self.threat_indicators.values()
                    if time.time() - ind.last_seen < 86400
                ])
            }
        }

"""Create DFARS continuous risk assessment system."""
def create_continuous_risk_assessment(config_path: Optional[str] = None) -> DFARSContinuousRiskAssessment:
    """Create DFARS continuous risk assessment system."""
    return DFARSContinuousRiskAssessment(config_path)

