"""
Extracted operations service from defense_industry_evidence_generator

Automatically generated by God Object Decomposer
"""

from dataclasses import dataclass
import sys
import hashlib
from lib.shared.utilities import get_logger
import os
from typing import Dict, List, Optional, Any
import asyncio
import json
import shutil


def __init__(self, project_root: str = None):
        self.project_root = Path(project_root or os.getcwd())
        self.theater_detector = EnterpriseTheaterDetector(project_root)
        self.continuous_monitor = ContinuousTheaterMonitor(project_root)

        # Evidence collection
        self.evidence_items: List[AuditEvidence] = []
        self.package_metadata = None

        # Output directory
        self.evidence_output_dir = self.project_root / ".claude" / ".artifacts" / "defense_evidence"
        self.evidence_output_dir.mkdir(parents=True, exist_ok=True)

"""Generate executive summary of evidence package"""
def _generate_executive_summary(self, *evidence_data) -> Dict[str, Any]:
        """Generate executive summary of evidence package"""

        theater_evidence, math_evidence, performance_evidence, security_evidence, compliance_evidence, monitoring_evidence = evidence_data

        # Calculate overall scores
        theater_score = theater_evidence["evidence_summary"]["analysis_summary"]["overall_compliance_score"]
        math_score = math_evidence["validation_summary"]["accuracy_rate"]
        perf_score = performance_evidence["performance_summary"]["performance_score"]
        security_score = security_evidence["security_summary"]["security_effectiveness"]
        compliance_score = compliance_evidence["framework_summary"]["framework_effectiveness"]
        monitoring_score = monitoring_evidence["monitoring_summary"]["capability_completeness"]

        # Calculate weighted overall score
        weights = [0.25, 0.20, 0.15, 0.25, 0.10, 0.5]  # Theater detection and security are most important
        scores = [theater_score, math_score, perf_score, security_score, compliance_score, monitoring_score]
        overall_score = sum(w * s for w, s in zip(weights, scores))

        # Determine certification status
        critical_violations = theater_evidence["evidence_summary"]["violation_statistics"]["critical_violations"]
        zero_tolerance_met = critical_violations == 0
        defense_ready = zero_tolerance_met and overall_score >= 0.95

        return {
            "overall_assessment": {
                "overall_compliance_score": overall_score,
                "zero_tolerance_met": zero_tolerance_met,
                "defense_industry_ready": defense_ready,
                "certification_recommendation": "APPROVED" if defense_ready else "REQUIRES_REMEDIATION"
            },
            "component_scores": {
                "theater_detection": theater_score,
                "mathematical_validation": math_score,
                "performance_verification": perf_score,
                "security_controls": security_score,
                "compliance_frameworks": compliance_score,
                "continuous_monitoring": monitoring_score
            },
            "critical_findings": {
                "theater_violations": critical_violations,
                "security_gaps": len([item for item in self.evidence_items
                                   if item.criticality_level == "CRITICAL" and item.validation_status != "VERIFIED"]),
                "compliance_gaps": len([item for item in self.evidence_items
                                     if item.validation_status == "FAILED"])
            },
            "evidence_completeness": {
                "total_evidence_items": len(self.evidence_items),
                "verified_items": len([item for item in self.evidence_items if item.validation_status == "VERIFIED"]),
                "evidence_coverage": len([item for item in self.evidence_items if item.validation_status == "VERIFIED"]) / len(self.evidence_items) if self.evidence_items else 0
            }
        }

"""Generate unique package ID"""
def _generate_package_id(self) -> str:
        """Generate unique package ID"""
        timestamp = datetime.now(timezone.utc).strftime("%Y%m%d_%H%M%S")
        project_hash = hashlib.sha256(str(self.project_root).encode()).hexdigest()[:8]
        return f"DEV_{timestamp}_{project_hash}"

"""Calculate hash of entire package for integrity verification"""
def _calculate_package_hash(self, package_dir: Path) -> str:
        """Calculate hash of entire package for integrity verification"""
        hash_sha256 = hashlib.sha256()

        for root, dirs, files in os.walk(package_dir):
            dirs.sort()  # Ensure consistent ordering
            for file in sorted(files):
                file_path = Path(root) / file
                try:
                    with open(file_path, 'rb') as f:
                        for chunk in iter(lambda: f.read(4096), b""):
                            hash_sha256.update(chunk)
                except:
                    continue

        return hash_sha256.hexdigest()

"""Create defense industry evidence generator"""
def create_defense_evidence_generator(project_root: str = None) -> DefenseIndustryEvidenceGenerator:
    """Create defense industry evidence generator"""
    return DefenseIndustryEvidenceGenerator(project_root)

