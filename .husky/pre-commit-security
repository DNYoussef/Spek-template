#!/usr/bin/env bash

# Pre-commit Security Hook
# Validates code for security vulnerabilities before commit

set -e

echo "üõ°Ô∏è  Running security validation..."

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Track failures
SECURITY_FAILURES=0

# Function to check for dangerous patterns
check_dangerous_patterns() {
  echo "üîç Checking for dangerous code patterns..."

  # Patterns to detect
  PATTERNS=(
    "eval\("
    "exec\("
    "require\(.*user"
    "Function\("
    "__import__"
    "os\.system"
    "subprocess\.call.*shell=True"
  )

  for pattern in "${PATTERNS[@]}"; do
    if git diff --cached --name-only | xargs grep -rn "$pattern" 2>/dev/null; then
      echo -e "${RED}‚ùå Dangerous pattern detected: $pattern${NC}"
      echo "   Consider using safer alternatives"
      ((SECURITY_FAILURES++))
    fi
  done
}

# Function to run Semgrep if available
run_semgrep() {
  if command -v semgrep &> /dev/null; then
    echo "üî¨ Running Semgrep security scan..."

    # Get staged files
    STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(js|ts|py|sh)$' || true)

    if [ -n "$STAGED_FILES" ]; then
      # Run Semgrep on staged files
      if ! semgrep --config=auto --severity=ERROR --severity=WARNING $STAGED_FILES 2>/dev/null; then
        echo -e "${RED}‚ùå Semgrep found security issues${NC}"
        ((SECURITY_FAILURES++))
      else
        echo -e "${GREEN}‚úÖ Semgrep scan passed${NC}"
      fi
    fi
  else
    echo -e "${YELLOW}‚ö†Ô∏è  Semgrep not installed, skipping automated scan${NC}"
    echo "   Install with: pip install semgrep"
  fi
}

# Function to check for hardcoded secrets
check_secrets() {
  echo "üîê Checking for hardcoded secrets..."

  SECRET_PATTERNS=(
    "password\s*=\s*['\"][^'\"]+['\"]"
    "api[_-]?key\s*=\s*['\"][^'\"]+['\"]"
    "secret\s*=\s*['\"][^'\"]+['\"]"
    "token\s*=\s*['\"][^'\"]+['\"]"
    "AWS_SECRET_ACCESS_KEY"
    "ANTHROPIC_API_KEY\s*=\s*['\"]sk-"
  )

  for pattern in "${SECRET_PATTERNS[@]}"; do
    if git diff --cached | grep -iE "$pattern" 2>/dev/null; then
      echo -e "${RED}‚ùå Potential hardcoded secret detected: $pattern${NC}"
      echo "   Use environment variables instead"
      ((SECURITY_FAILURES++))
    fi
  done
}

# Function to validate file permissions
check_permissions() {
  echo "üîí Checking file permissions..."

  # Check for overly permissive files
  STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

  for file in $STAGED_FILES; do
    if [ -f "$file" ]; then
      PERMS=$(stat -c "%a" "$file" 2>/dev/null || stat -f "%A" "$file" 2>/dev/null)

      # Check for world-writable files
      if [ "$PERMS" = "777" ] || [ "$PERMS" = "666" ]; then
        echo -e "${YELLOW}‚ö†Ô∏è  File has overly permissive permissions: $file ($PERMS)${NC}"
        echo "   Consider: chmod 644 $file (for files) or chmod 755 $file (for executables)"
      fi
    fi
  done
}

# Function to check for vulnerable dependencies
check_dependencies() {
  if [ -f "package.json" ] && command -v npm &> /dev/null; then
    echo "üì¶ Checking for vulnerable dependencies..."

    if git diff --cached --name-only | grep -q "package.json\|package-lock.json"; then
      if ! npm audit --audit-level=high --production 2>/dev/null; then
        echo -e "${YELLOW}‚ö†Ô∏è  Vulnerable dependencies detected${NC}"
        echo "   Run: npm audit fix"
        # Don't fail the commit, just warn
      fi
    fi
  fi
}

# Run all security checks
check_dangerous_patterns
run_semgrep
check_secrets
check_permissions
check_dependencies

# Final verdict
if [ $SECURITY_FAILURES -gt 0 ]; then
  echo ""
  echo -e "${RED}‚ùå Security validation failed with $SECURITY_FAILURES issue(s)${NC}"
  echo "   Fix the issues above and try again"
  echo "   To bypass (not recommended): git commit --no-verify"
  exit 1
else
  echo ""
  echo -e "${GREEN}‚úÖ All security checks passed!${NC}"
  exit 0
fi