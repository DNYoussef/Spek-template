import * as fs from 'fs/promises';
import * as path from 'path';
import { BenchmarkResult } from '../benchmarking/PerformanceBenchmarker';
import { LoadTestResult } from '../load/LoadTester';
import { SystemMetrics } from '../monitoring/RealTimeMonitor';
import { CrossPlatformReport } from '../benchmarking/CrossPlatformBenchmark';

export interface ReportData {
  benchmarks?: BenchmarkResult[];
  loadTests?: LoadTestResult[];
  systemMetrics?: SystemMetrics[];
  crossPlatform?: CrossPlatformReport;
  metadata?: {
    generatedAt: number;
    platform: string;
    nodeVersion: string;
    reportVersion: string;
  };
}

export interface ReportConfig {
  title: string;
  format: 'html' | 'json' | 'csv' | 'markdown' | 'pdf';
  includeCharts: boolean;
  includeRawData: boolean;
  timeRange?: {
    start: number;
    end: number;
  };
  filters?: {
    benchmarkNames?: string[];
    loadTestNames?: string[];
    metricTypes?: string[];
  };
}

export class ReportGenerator {
  private templates: Map<string, string> = new Map();

  constructor() {
    this.initializeTemplates();
  }

  private initializeTemplates(): void {
    // HTML template for performance reports
    const htmlTemplate = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{TITLE}}</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f5f5f5; }
        .header { background-color: #2c3e50; color: white; padding: 20px; border-radius: 5px; margin-bottom: 20px; }
        .section { background-color: white; padding: 20px; margin-bottom: 20px; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .metric { display: inline-block; margin: 10px; padding: 10px; background-color: #ecf0f1; border-radius: 3px; }
        .metric-value { font-size: 24px; font-weight: bold; color: #2980b9; }
        .metric-label { font-size: 12px; color: #7f8c8d; }
        table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        th, td { padding: 8px; text-align: left; border-bottom: 1px solid #ddd; }
        th { background-color: #34495e; color: white; }
        .success { color: #27ae60; }
        .warning { color: #f39c12; }
        .error { color: #e74c3c; }
        .chart-container { margin: 20px 0; }
    </style>
</head>
<body>
    <div class="header">
        <h1>{{TITLE}}</h1>
        <p>Generated on {{GENERATED_DATE}}</p>
        <p>Platform: {{PLATFORM}} | Node.js: {{NODE_VERSION}}</p>
    </div>
    {{CONTENT}}
</body>
</html>`;

    this.templates.set('html', htmlTemplate);

    // Markdown template
    const markdownTemplate = `# {{TITLE}}

**Generated:** {{GENERATED_DATE}}
**Platform:** {{PLATFORM}}
**Node.js:** {{NODE_VERSION}}

{{CONTENT}}

---
*Report generated by Performance Benchmarking Framework*
`;

    this.templates.set('markdown', markdownTemplate);
  }

  async generateReport(data: ReportData, config: ReportConfig): Promise<string> {
    // Filter data based on config
    const filteredData = this.filterData(data, config);

    // Generate content based on format
    switch (config.format) {
      case 'html':
        return this.generateHtmlReport(filteredData, config);
      case 'json':
        return this.generateJsonReport(filteredData, config);
      case 'csv':
        return this.generateCsvReport(filteredData, config);
      case 'markdown':
        return this.generateMarkdownReport(filteredData, config);
      default:
        throw new Error(`Unsupported report format: ${config.format}`);
    }
  }

  private filterData(data: ReportData, config: ReportConfig): ReportData {
    const filtered: ReportData = { ...data };

    // Time range filtering
    if (config.timeRange) {
      const { start, end } = config.timeRange;

      if (filtered.benchmarks) {
        filtered.benchmarks = filtered.benchmarks.filter(
          b => b.timestamp >= start && b.timestamp <= end
        );
      }

      if (filtered.loadTests) {
        filtered.loadTests = filtered.loadTests.filter(
          lt => lt.startTime >= start && lt.endTime <= end
        );
      }

      if (filtered.systemMetrics) {
        filtered.systemMetrics = filtered.systemMetrics.filter(
          sm => sm.timestamp >= start && sm.timestamp <= end
        );
      }
    }

    // Name filtering
    if (config.filters?.benchmarkNames && filtered.benchmarks) {
      filtered.benchmarks = filtered.benchmarks.filter(
        b => config.filters!.benchmarkNames!.includes(b.name)
      );
    }

    if (config.filters?.loadTestNames && filtered.loadTests) {
      filtered.loadTests = filtered.loadTests.filter(
        lt => config.filters!.loadTestNames!.includes(lt.testName)
      );
    }

    return filtered;
  }

  private generateHtmlReport(data: ReportData, config: ReportConfig): string {
    let content = '';

    // Executive Summary
    content += this.generateExecutiveSummaryHtml(data);

    // Benchmark Results
    if (data.benchmarks && data.benchmarks.length > 0) {
      content += this.generateBenchmarkSectionHtml(data.benchmarks, config);
    }

    // Load Test Results
    if (data.loadTests && data.loadTests.length > 0) {
      content += this.generateLoadTestSectionHtml(data.loadTests, config);
    }

    // System Metrics
    if (data.systemMetrics && data.systemMetrics.length > 0) {
      content += this.generateSystemMetricsSectionHtml(data.systemMetrics, config);
    }

    // Cross Platform Results
    if (data.crossPlatform) {
      content += this.generateCrossPlatformSectionHtml(data.crossPlatform);
    }

    // Raw Data Section
    if (config.includeRawData) {
      content += this.generateRawDataSectionHtml(data);
    }

    const template = this.templates.get('html')!;
    return template
      .replace(/{{TITLE}}/g, config.title)
      .replace(/{{GENERATED_DATE}}/g, new Date().toISOString())
      .replace(/{{PLATFORM}}/g, process.platform)
      .replace(/{{NODE_VERSION}}/g, process.version)
      .replace(/{{CONTENT}}/g, content);
  }

  private generateExecutiveSummaryHtml(data: ReportData): string {
    const totalBenchmarks = data.benchmarks?.length || 0;
    const totalLoadTests = data.loadTests?.length || 0;
    const totalMetrics = data.systemMetrics?.length || 0;

    let avgOpsPerSec = 0;
    if (data.benchmarks && data.benchmarks.length > 0) {
      avgOpsPerSec = data.benchmarks.reduce((sum, b) => sum + b.operationsPerSecond, 0) / data.benchmarks.length;
    }

    let avgResponseTime = 0;
    if (data.loadTests && data.loadTests.length > 0) {
      avgResponseTime = data.loadTests.reduce((sum, lt) => sum + lt.averageResponseTime, 0) / data.loadTests.length;
    }

    return `
    <div class="section">
        <h2>Executive Summary</h2>
        <div>
            <div class="metric">
                <div class="metric-value">${totalBenchmarks}</div>
                <div class="metric-label">Benchmarks Run</div>
            </div>
            <div class="metric">
                <div class="metric-value">${totalLoadTests}</div>
                <div class="metric-label">Load Tests</div>
            </div>
            <div class="metric">
                <div class="metric-value">${totalMetrics}</div>
                <div class="metric-label">Metric Samples</div>
            </div>
            <div class="metric">
                <div class="metric-value">${avgOpsPerSec.toFixed(2)}</div>
                <div class="metric-label">Avg Ops/Sec</div>
            </div>
            <div class="metric">
                <div class="metric-value">${avgResponseTime.toFixed(2)}ms</div>
                <div class="metric-label">Avg Response Time</div>
            </div>
        </div>
    </div>`;
  }

  private generateBenchmarkSectionHtml(benchmarks: BenchmarkResult[], config: ReportConfig): string {
    let tableRows = '';
    for (const benchmark of benchmarks) {
      tableRows += `
        <tr>
            <td>${benchmark.name}</td>
            <td>${benchmark.operationsPerSecond.toFixed(2)}</td>
            <td>${benchmark.avgTime.toFixed(4)}ms</td>
            <td>${benchmark.percentiles.p95.toFixed(4)}ms</td>
            <td>${benchmark.percentiles.p99.toFixed(4)}ms</td>
            <td>${benchmark.iterations}</td>
            <td>${(benchmark.memoryUsage.heapUsed / 1024 / 1024).toFixed(2)}MB</td>
        </tr>`;
    }

    return `
    <div class="section">
        <h2>Benchmark Results</h2>
        <table>
            <thead>
                <tr>
                    <th>Test Name</th>
                    <th>Ops/Sec</th>
                    <th>Avg Time</th>
                    <th>95th %ile</th>
                    <th>99th %ile</th>
                    <th>Iterations</th>
                    <th>Memory</th>
                </tr>
            </thead>
            <tbody>
                ${tableRows}
            </tbody>
        </table>
    </div>`;
  }

  private generateLoadTestSectionHtml(loadTests: LoadTestResult[], config: ReportConfig): string {
    let tableRows = '';
    for (const test of loadTests) {
      const statusClass = test.errorRate < 1 ? 'success' : test.errorRate < 5 ? 'warning' : 'error';
      tableRows += `
        <tr>
            <td>${test.testName}</td>
            <td>${test.requestsPerSecond.toFixed(2)}</td>
            <td>${test.averageResponseTime.toFixed(2)}ms</td>
            <td>${test.p95ResponseTime.toFixed(2)}ms</td>
            <td>${test.totalRequests}</td>
            <td class="${statusClass}">${test.errorRate.toFixed(2)}%</td>
            <td>${(test.duration / 1000).toFixed(2)}s</td>
        </tr>`;
    }

    return `
    <div class="section">
        <h2>Load Test Results</h2>
        <table>
            <thead>
                <tr>
                    <th>Test Name</th>
                    <th>Req/Sec</th>
                    <th>Avg Response</th>
                    <th>95th %ile</th>
                    <th>Total Requests</th>
                    <th>Error Rate</th>
                    <th>Duration</th>
                </tr>
            </thead>
            <tbody>
                ${tableRows}
            </tbody>
        </table>
    </div>`;
  }

  private generateSystemMetricsSectionHtml(metrics: SystemMetrics[], config: ReportConfig): string {
    const latest = metrics[metrics.length - 1];
    const avgCpu = metrics.reduce((sum, m) => sum + m.cpu.usage, 0) / metrics.length;
    const avgMemory = metrics.reduce((sum, m) => sum + m.memory.usagePercent, 0) / metrics.length;

    return `
    <div class="section">
        <h2>System Metrics</h2>
        <div>
            <div class="metric">
                <div class="metric-value">${latest.cpu.usage.toFixed(1)}%</div>
                <div class="metric-label">Current CPU</div>
            </div>
            <div class="metric">
                <div class="metric-value">${avgCpu.toFixed(1)}%</div>
                <div class="metric-label">Avg CPU</div>
            </div>
            <div class="metric">
                <div class="metric-value">${latest.memory.usagePercent.toFixed(1)}%</div>
                <div class="metric-label">Current Memory</div>
            </div>
            <div class="metric">
                <div class="metric-value">${avgMemory.toFixed(1)}%</div>
                <div class="metric-label">Avg Memory</div>
            </div>
            <div class="metric">
                <div class="metric-value">${metrics.length}</div>
                <div class="metric-label">Data Points</div>
            </div>
        </div>
    </div>`;
  }

  private generateCrossPlatformSectionHtml(crossPlatform: CrossPlatformReport): string {
    let platformRows = '';
    for (const platform of crossPlatform.platformResults) {
      const avgOps = platform.results.reduce((sum, r) => sum + r.operationsPerSecond, 0) / platform.results.length;
      platformRows += `
        <tr>
            <td>${platform.platform} ${platform.arch}</td>
            <td>${platform.nodeVersion}</td>
            <td>${platform.systemInfo.cpus}</td>
            <td>${(platform.systemInfo.totalMemory / 1024 / 1024 / 1024).toFixed(2)} GB</td>
            <td>${avgOps.toFixed(2)}</td>
            <td>${platform.results.length}</td>
        </tr>`;
    }

    return `
    <div class="section">
        <h2>Cross-Platform Results</h2>
        <p><strong>Best Performing:</strong> ${crossPlatform.summary.bestPerforming}</p>
        <p><strong>Average Performance:</strong> ${crossPlatform.summary.averagePerformance.toFixed(2)} ops/sec</p>
        <table>
            <thead>
                <tr>
                    <th>Platform</th>
                    <th>Node Version</th>
                    <th>CPUs</th>
                    <th>Memory</th>
                    <th>Avg Ops/Sec</th>
                    <th>Tests</th>
                </tr>
            </thead>
            <tbody>
                ${platformRows}
            </tbody>
        </table>
    </div>`;
  }

  private generateRawDataSectionHtml(data: ReportData): string {
    return `
    <div class="section">
        <h2>Raw Data</h2>
        <details>
            <summary>Click to expand raw data (JSON format)</summary>
            <pre style="background-color: #f8f9fa; padding: 15px; border-radius: 3px; overflow-x: auto; font-size: 12px;">
${JSON.stringify(data, null, 2)}
            </pre>
        </details>
    </div>`;
  }

  private generateMarkdownReport(data: ReportData, config: ReportConfig): string {
    let content = '';

    // Executive Summary
    content += '## Executive Summary\n\n';
    const totalBenchmarks = data.benchmarks?.length || 0;
    const totalLoadTests = data.loadTests?.length || 0;
    const totalMetrics = data.systemMetrics?.length || 0;

    content += `- **Benchmarks Run:** ${totalBenchmarks}\n`;
    content += `- **Load Tests:** ${totalLoadTests}\n`;
    content += `- **Metric Samples:** ${totalMetrics}\n\n`;

    // Benchmark Results
    if (data.benchmarks && data.benchmarks.length > 0) {
      content += '## Benchmark Results\n\n';
      content += '| Test Name | Ops/Sec | Avg Time | 95th %ile | 99th %ile | Iterations |\n';
      content += '|-----------|---------|----------|-----------|-----------|------------|\n';

      for (const benchmark of data.benchmarks) {
        content += `| ${benchmark.name} | ${benchmark.operationsPerSecond.toFixed(2)} | ${benchmark.avgTime.toFixed(4)}ms | ${benchmark.percentiles.p95.toFixed(4)}ms | ${benchmark.percentiles.p99.toFixed(4)}ms | ${benchmark.iterations} |\n`;
      }
      content += '\n';
    }

    // Load Test Results
    if (data.loadTests && data.loadTests.length > 0) {
      content += '## Load Test Results\n\n';
      content += '| Test Name | Req/Sec | Avg Response | 95th %ile | Total Requests | Error Rate | Duration |\n';
      content += '|-----------|---------|--------------|-----------|----------------|------------|----------|\n';

      for (const test of data.loadTests) {
        content += `| ${test.testName} | ${test.requestsPerSecond.toFixed(2)} | ${test.averageResponseTime.toFixed(2)}ms | ${test.p95ResponseTime.toFixed(2)}ms | ${test.totalRequests} | ${test.errorRate.toFixed(2)}% | ${(test.duration / 1000).toFixed(2)}s |\n`;
      }
      content += '\n';
    }

    // Cross Platform Results
    if (data.crossPlatform) {
      content += '## Cross-Platform Results\n\n';
      content += `**Best Performing:** ${data.crossPlatform.summary.bestPerforming}\n`;
      content += `**Average Performance:** ${data.crossPlatform.summary.averagePerformance.toFixed(2)} ops/sec\n\n`;

      content += '| Platform | Node Version | CPUs | Memory | Avg Ops/Sec | Tests |\n';
      content += '|----------|--------------|------|--------|-------------|-------|\n';

      for (const platform of data.crossPlatform.platformResults) {
        const avgOps = platform.results.reduce((sum, r) => sum + r.operationsPerSecond, 0) / platform.results.length;
        content += `| ${platform.platform} ${platform.arch} | ${platform.nodeVersion} | ${platform.systemInfo.cpus} | ${(platform.systemInfo.totalMemory / 1024 / 1024 / 1024).toFixed(2)} GB | ${avgOps.toFixed(2)} | ${platform.results.length} |\n`;
      }
      content += '\n';
    }

    const template = this.templates.get('markdown')!;
    return template
      .replace(/{{TITLE}}/g, config.title)
      .replace(/{{GENERATED_DATE}}/g, new Date().toISOString())
      .replace(/{{PLATFORM}}/g, process.platform)
      .replace(/{{NODE_VERSION}}/g, process.version)
      .replace(/{{CONTENT}}/g, content);
  }

  private generateJsonReport(data: ReportData, config: ReportConfig): string {
    const report = {
      title: config.title,
      generatedAt: new Date().toISOString(),
      platform: process.platform,
      nodeVersion: process.version,
      config: config,
      data: data
    };

    return JSON.stringify(report, null, 2);
  }

  private generateCsvReport(data: ReportData, config: ReportConfig): string {
    let csv = '';

    // Benchmark Results CSV
    if (data.benchmarks && data.benchmarks.length > 0) {
      csv += 'Benchmark Results\n';
      csv += 'Name,Ops/Sec,Avg Time (ms),Min Time (ms),Max Time (ms),P95 (ms),P99 (ms),Iterations,Memory (MB)\n';

      for (const benchmark of data.benchmarks) {
        csv += `${benchmark.name},${benchmark.operationsPerSecond},${benchmark.avgTime},${benchmark.minTime},${benchmark.maxTime},${benchmark.percentiles.p95},${benchmark.percentiles.p99},${benchmark.iterations},${(benchmark.memoryUsage.heapUsed / 1024 / 1024).toFixed(2)}\n`;
      }
      csv += '\n';
    }

    // Load Test Results CSV
    if (data.loadTests && data.loadTests.length > 0) {
      csv += 'Load Test Results\n';
      csv += 'Name,Req/Sec,Avg Response (ms),P95 (ms),Total Requests,Successful,Failed,Error Rate (%),Duration (s)\n';

      for (const test of data.loadTests) {
        csv += `${test.testName},${test.requestsPerSecond},${test.averageResponseTime},${test.p95ResponseTime},${test.totalRequests},${test.successfulRequests},${test.failedRequests},${test.errorRate},${(test.duration / 1000).toFixed(2)}\n`;
      }
      csv += '\n';
    }

    return csv;
  }

  async saveReport(content: string, filePath: string): Promise<void> {
    await fs.writeFile(filePath, content, 'utf-8');
  }

  async generateAndSaveReport(
    data: ReportData,
    config: ReportConfig,
    outputPath: string
  ): Promise<void> {
    const content = await this.generateReport(data, config);
    await this.saveReport(content, outputPath);
  }

  async generateMultiFormatReports(
    data: ReportData,
    baseConfig: Omit<ReportConfig, 'format'>,
    outputDir: string,
    formats: ReportConfig['format'][] = ['html', 'json', 'markdown', 'csv']
  ): Promise<string[]> {
    const generatedFiles: string[] = [];

    for (const format of formats) {
      const config: ReportConfig = { ...baseConfig, format };
      const extension = format === 'html' ? 'html' : format === 'json' ? 'json' : format === 'csv' ? 'csv' : 'md';
      const fileName = `performance-report.${extension}`;
      const filePath = path.join(outputDir, fileName);

      await this.generateAndSaveReport(data, config, filePath);
      generatedFiles.push(filePath);
    }

    return generatedFiles;
  }

  generateComparisonReport(
    baseline: ReportData,
    current: ReportData,
    config: ReportConfig
  ): string {
    let content = '';

    // Benchmark comparisons
    if (baseline.benchmarks && current.benchmarks) {
      content += this.generateBenchmarkComparison(baseline.benchmarks, current.benchmarks);
    }

    // Load test comparisons
    if (baseline.loadTests && current.loadTests) {
      content += this.generateLoadTestComparison(baseline.loadTests, current.loadTests);
    }

    if (config.format === 'html') {
      const template = this.templates.get('html')!;
      return template
        .replace(/{{TITLE}}/g, `${config.title} - Comparison Report`)
        .replace(/{{GENERATED_DATE}}/g, new Date().toISOString())
        .replace(/{{PLATFORM}}/g, process.platform)
        .replace(/{{NODE_VERSION}}/g, process.version)
        .replace(/{{CONTENT}}/g, content);
    } else if (config.format === 'markdown') {
      const template = this.templates.get('markdown')!;
      return template
        .replace(/{{TITLE}}/g, `${config.title} - Comparison Report`)
        .replace(/{{GENERATED_DATE}}/g, new Date().toISOString())
        .replace(/{{PLATFORM}}/g, process.platform)
        .replace(/{{NODE_VERSION}}/g, process.version)
        .replace(/{{CONTENT}}/g, content);
    }

    return content;
  }

  private generateBenchmarkComparison(baseline: BenchmarkResult[], current: BenchmarkResult[]): string {
    let content = '<div class="section"><h2>Benchmark Comparison</h2><table>';
    content += '<thead><tr><th>Test Name</th><th>Baseline Ops/Sec</th><th>Current Ops/Sec</th><th>Change</th><th>Status</th></tr></thead><tbody>';

    for (const currentBench of current) {
      const baselineBench = baseline.find(b => b.name === currentBench.name);
      if (baselineBench) {
        const change = ((currentBench.operationsPerSecond - baselineBench.operationsPerSecond) / baselineBench.operationsPerSecond) * 100;
        const status = change > 5 ? 'success' : change < -5 ? 'error' : 'warning';
        const changeText = change > 0 ? `+${change.toFixed(2)}%` : `${change.toFixed(2)}%`;

        content += `<tr>
          <td>${currentBench.name}</td>
          <td>${baselineBench.operationsPerSecond.toFixed(2)}</td>
          <td>${currentBench.operationsPerSecond.toFixed(2)}</td>
          <td class="${status}">${changeText}</td>
          <td class="${status}">${change > 5 ? 'Improved' : change < -5 ? 'Degraded' : 'Stable'}</td>
        </tr>`;
      }
    }

    content += '</tbody></table></div>';
    return content;
  }

  private generateLoadTestComparison(baseline: LoadTestResult[], current: LoadTestResult[]): string {
    let content = '<div class="section"><h2>Load Test Comparison</h2><table>';
    content += '<thead><tr><th>Test Name</th><th>Baseline RPS</th><th>Current RPS</th><th>Change</th><th>Status</th></tr></thead><tbody>';

    for (const currentTest of current) {
      const baselineTest = baseline.find(t => t.testName === currentTest.testName);
      if (baselineTest) {
        const change = ((currentTest.requestsPerSecond - baselineTest.requestsPerSecond) / baselineTest.requestsPerSecond) * 100;
        const status = change > 5 ? 'success' : change < -5 ? 'error' : 'warning';
        const changeText = change > 0 ? `+${change.toFixed(2)}%` : `${change.toFixed(2)}%`;

        content += `<tr>
          <td>${currentTest.testName}</td>
          <td>${baselineTest.requestsPerSecond.toFixed(2)}</td>
          <td>${currentTest.requestsPerSecond.toFixed(2)}</td>
          <td class="${status}">${changeText}</td>
          <td class="${status}">${change > 5 ? 'Improved' : change < -5 ? 'Degraded' : 'Stable'}</td>
        </tr>`;
      }
    }

    content += '</tbody></table></div>';
    return content;
  }
}