"""
Extracted validation service from cache_performance_profiler

Automatically generated by God Object Decomposer
"""

from caching.ast_cache import ASTCache
import os
import sys
import time
from dataclasses import field
from typing import Dict, List, Optional, Any
from collections import deque
from typing import Set
from typing import Tuple
from dataclasses import dataclass
from streaming.incremental_cache import IncrementalCache
import threading
from optimization.file_cache import FileContentCache
from collections import defaultdict
from typing import Callable


"""Invalidate entry across all dependent caches."""
    def invalidate_entry(self, cache_name: str, entry_key: str) -> None:
        """Invalidate entry across all dependent caches."""
        with self._lock:
            # Notify direct listeners
            for listener in self.invalidation_listeners[cache_name]:
                try:
                    listener(entry_key)
                except Exception as e:
                    logger.error(f"Cache invalidation listener failed: {e}")

            # Propagate to dependent caches
            for dependent_cache in self.cache_dependencies[cache_name]:
                self.invalidate_entry(dependent_cache, entry_key)

            self.coherence_stats["invalidations_propagated"] += 1

"""Check current memory pressure across all caches."""
    def _check_memory_pressure(self) -> float:
        """Check current memory pressure across all caches."""
        total_used = 0
        total_max = 0

        # Check file cache memory
        if self.file_cache:
            memory_info = self.file_cache.get_memory_usage()
            total_used += memory_info.get('file_cache_bytes', 0)
            total_max += memory_info.get('max_memory_bytes', 0)

        # Estimate AST cache memory (simplified)
        if self.ast_cache:
            stats = self.ast_cache.get_cache_statistics()
            total_used += stats.get('memory_usage_mb', 0) * 1024 * 1024
            total_max += stats.get('memory_limit_mb', 0) * 1024 * 1024

        return total_used / total_max if total_max > 0 else 0.0

