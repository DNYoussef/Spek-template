import { describe, test, expect, beforeEach, afterEach } from '@jest/globals';\nimport { CrossPrincessMemoryCoordinator } from '../../src/memory/coordination/CrossPrincessMemoryCoordinator';\nimport { LangroidMemoryManager } from '../../src/memory/langroid/LangroidMemoryManager';\nimport { MemoryUsageAnalyzer } from '../../src/memory/analytics/MemoryUsageAnalyzer';\nimport { DistributedMemorySync } from '../../src/memory/sync/DistributedMemorySync';\n\ndescribe('Memory System Integration Tests', () => {\n  let coordinator: CrossPrincessMemoryCoordinator;\n  let memoryManager: LangroidMemoryManager;\n  let analyzer: MemoryUsageAnalyzer;\n  let syncSystem: DistributedMemorySync;\n\n  beforeEach(async () => {\n    // Initialize memory manager\n    memoryManager = new LangroidMemoryManager({\n      maxSizeBytes: 10 * 1024 * 1024, // 10MB\n      compressionEnabled: true,\n      persistenceEnabled: false // Disable for tests\n    });\n\n    // Initialize coordinator\n    coordinator = new CrossPrincessMemoryCoordinator({\n      totalMemoryLimit: 60 * 1024 * 1024,\n      princessMemoryLimit: 10 * 1024 * 1024,\n      enableConflictResolution: true,\n      enableLoadBalancing: true\n    });\n\n    // Initialize analyzer\n    analyzer = new MemoryUsageAnalyzer(memoryManager, {\n      enableRealTimeAnalysis: false, // Disable for tests\n      enablePredictiveAnalysis: true\n    });\n\n    // Initialize sync system\n    syncSystem = new DistributedMemorySync(memoryManager, {\n      nodeId: 'test-node',\n      maxNodes: 5,\n      consistencyLevel: 'eventual'\n    });\n  });\n\n  afterEach(async () => {\n    await coordinator.shutdown();\n    await memoryManager.shutdown();\n    await analyzer.shutdown();\n    await syncSystem.shutdown();\n  });\n\n  describe('Cross-Princess Memory Coordination', () => {\n    test('should register multiple Princesses successfully', async () => {\n      const princesses = [\n        {\n          principalId: 'architecture-princess',\n          domain: 'architecture',\n          maxMemorySize: 10 * 1024 * 1024,\n          partitionIds: ['architecture', 'shared'],\n          priority: 1,\n          enableSharing: true,\n          enableVersioning: true\n        },\n        {\n          principalId: 'development-princess',\n          domain: 'development',\n          maxMemorySize: 10 * 1024 * 1024,\n          partitionIds: ['development', 'shared'],\n          priority: 2,\n          enableSharing: true,\n          enableVersioning: true\n        }\n      ];\n\n      for (const config of princesses) {\n        await coordinator.registerPrincess(config);\n      }\n\n      const statuses = coordinator.getPrincessStatuses();\n      expect(statuses).toHaveLength(2);\n      expect(statuses[0].principalId).toBe('architecture-princess');\n      expect(statuses[1].principalId).toBe('development-princess');\n    });\n\n    test('should enforce 10MB memory limit per Princess', async () => {\n      await coordinator.registerPrincess({\n        principalId: 'test-princess',\n        domain: 'test',\n        maxMemorySize: 10 * 1024 * 1024,\n        partitionIds: ['test'],\n        priority: 1,\n        enableSharing: false,\n        enableVersioning: false\n      });\n\n      // Try to store data that exceeds 10MB\n      const largeData = {\n        payload: 'x'.repeat(11 * 1024 * 1024) // 11MB\n      };\n\n      // This should fail or trigger eviction\n      const result = await coordinator.store('test-princess', 'large-data', largeData);\n      \n      const statuses = coordinator.getPrincessStatuses();\n      const testPrincess = statuses.find(s => s.principalId === 'test-princess');\n      \n      expect(testPrincess).toBeDefined();\n      expect(testPrincess!.memoryUsage).toBeLessThanOrEqual(10 * 1024 * 1024);\n    });\n\n    test('should transfer memory between Princesses', async () => {\n      // Register two Princesses\n      await coordinator.registerPrincess({\n        principalId: 'source-princess',\n        domain: 'source',\n        maxMemorySize: 10 * 1024 * 1024,\n        partitionIds: ['source'],\n        priority: 1,\n        enableSharing: true,\n        enableVersioning: false\n      });\n\n      await coordinator.registerPrincess({\n        principalId: 'target-princess',\n        domain: 'target',\n        maxMemorySize: 10 * 1024 * 1024,\n        partitionIds: ['target'],\n        priority: 1,\n        enableSharing: true,\n        enableVersioning: false\n      });\n\n      // Store data in source Princess\n      const testData = { message: 'Hello from source!' };\n      await coordinator.store('source-princess', 'test-key', testData);\n\n      // Transfer to target Princess\n      const transferRequest = {\n        fromPrincess: 'source-princess',\n        toPrincess: 'target-princess',\n        keys: ['test-key'],\n        preserveOriginal: false,\n        priority: 1\n      };\n\n      const success = await coordinator.transferMemory(transferRequest);\n      expect(success).toBe(true);\n\n      // Verify data is in target Princess\n      const retrievedData = await coordinator.retrieve('target-princess', 'test-key');\n      expect(retrievedData).toEqual(testData);\n\n      // Verify data is removed from source Princess (preserveOriginal = false)\n      const sourceData = await coordinator.retrieve('source-princess', 'test-key');\n      expect(sourceData).toBeNull();\n    });\n\n    test('should synchronize memory across all Princesses', async () => {\n      // Register multiple Princesses\n      const princesses = ['princess-1', 'princess-2', 'princess-3'];\n      \n      for (const id of princesses) {\n        await coordinator.registerPrincess({\n          principalId: id,\n          domain: id.replace('-', ''),\n          maxMemorySize: 10 * 1024 * 1024,\n          partitionIds: ['shared'],\n          priority: 1,\n          enableSharing: true,\n          enableVersioning: false\n        });\n      }\n\n      // Store different data in each Princess\n      await coordinator.store('princess-1', 'data-1', { source: 'princess-1' });\n      await coordinator.store('princess-2', 'data-2', { source: 'princess-2' });\n      await coordinator.store('princess-3', 'data-3', { source: 'princess-3' });\n\n      // Synchronize all\n      const syncId = await coordinator.synchronizeAll('full');\n      expect(syncId).toBeDefined();\n      expect(typeof syncId).toBe('string');\n\n      // Wait for sync to complete\n      await new Promise(resolve => setTimeout(resolve, 1000));\n\n      const metrics = coordinator.getMetrics();\n      expect(metrics.totalSyncOperations).toBeGreaterThan(0);\n    });\n  });\n\n  describe('Memory Management Core', () => {\n    test('should store and retrieve data correctly', async () => {\n      const testData = {\n        id: 'test-1',\n        name: 'Test Data',\n        created: Date.now()\n      };\n\n      const success = await memoryManager.store('test-key', testData, 'default');\n      expect(success).toBe(true);\n\n      const retrieved = await memoryManager.retrieve('test-key');\n      expect(retrieved).toEqual(testData);\n    });\n\n    test('should compress data when enabled', async () => {\n      const largeData = {\n        content: 'x'.repeat(10000), // 10KB of repeated data\n        metadata: { compressed: true }\n      };\n\n      await memoryManager.store('large-key', largeData, 'default');\n      \n      const stats = memoryManager.getStats();\n      expect(stats.compressionRatio).toBeGreaterThan(1);\n    });\n\n    test('should enforce memory limits and evict entries', async () => {\n      // Fill memory close to limit\n      const entries = [];\n      for (let i = 0; i < 100; i++) {\n        const data = { id: i, content: 'x'.repeat(100000) }; // 100KB each\n        entries.push({ key: `entry-${i}`, data });\n      }\n\n      // Store all entries\n      for (const entry of entries) {\n        await memoryManager.store(entry.key, entry.data, 'default');\n      }\n\n      const stats = memoryManager.getStats();\n      expect(stats.totalSize).toBeLessThanOrEqual(10 * 1024 * 1024); // Should not exceed 10MB\n    });\n\n    test('should handle TTL expiration', async () => {\n      const testData = { message: 'This will expire' };\n      const ttl = 1000; // 1 second\n\n      await memoryManager.store('expiring-key', testData, 'default', ttl);\n\n      // Should be retrievable immediately\n      let retrieved = await memoryManager.retrieve('expiring-key');\n      expect(retrieved).toEqual(testData);\n\n      // Wait for expiration\n      await new Promise(resolve => setTimeout(resolve, 1500));\n\n      // Should be expired\n      retrieved = await memoryManager.retrieve('expiring-key');\n      expect(retrieved).toBeNull();\n    });\n  });\n\n  describe('Memory Usage Analysis', () => {\n    test('should analyze memory usage patterns', async () => {\n      // Store various types of data\n      const testData = [\n        { key: 'small-1', data: { size: 'small' } },\n        { key: 'small-2', data: { size: 'small' } },\n        { key: 'medium-1', data: { size: 'medium', content: 'x'.repeat(1000) } },\n        { key: 'large-1', data: { size: 'large', content: 'x'.repeat(10000) } }\n      ];\n\n      for (const item of testData) {\n        await memoryManager.store(item.key, item.data, 'default');\n      }\n\n      // Run analysis\n      const report = await analyzer.analyze();\n\n      expect(report).toBeDefined();\n      expect(report.timestamp).toBeGreaterThan(0);\n      expect(report.memoryStats).toBeDefined();\n      expect(report.usagePatterns).toBeInstanceOf(Array);\n      expect(report.overallScore).toBeGreaterThanOrEqual(0);\n      expect(report.overallScore).toBeLessThanOrEqual(100);\n      expect(report.recommendations).toBeInstanceOf(Array);\n    });\n\n    test('should identify optimization opportunities', async () => {\n      // Create scenario that should trigger optimization recommendations\n      const largeData = { content: 'x'.repeat(100000) }; // 100KB\n      \n      for (let i = 0; i < 50; i++) {\n        await memoryManager.store(`large-${i}`, largeData, 'default');\n      }\n\n      const report = await analyzer.analyze();\n\n      expect(report.optimizationOpportunities.length).toBeGreaterThan(0);\n      \n      const hasCompressionOpportunity = report.optimizationOpportunities\n        .some(opp => opp.type === 'compression');\n      \n      // Should recommend compression for large, similar data\n      expect(hasCompressionOpportunity).toBe(true);\n    });\n\n    test('should track memory trends over time', async () => {\n      // Generate some metric history\n      const dataPoints = [\n        { size: 1000 },\n        { size: 1500 },\n        { size: 2000 },\n        { size: 2500 },\n        { size: 3000 }\n      ];\n\n      for (const point of dataPoints) {\n        await memoryManager.store(`trend-${Date.now()}`, point, 'default');\n        await analyzer.analyze(); // This will add to history\n        await new Promise(resolve => setTimeout(resolve, 100));\n      }\n\n      const report = await analyzer.analyze();\n      \n      expect(report.trends.length).toBeGreaterThan(0);\n      \n      const sizeTrend = report.trends.find(t => t.metric.includes('Size'));\n      if (sizeTrend) {\n        expect(['increasing', 'decreasing', 'stable', 'volatile']).toContain(sizeTrend.trend);\n      }\n    });\n  });\n\n  describe('Distributed Memory Synchronization', () => {\n    test('should add and manage nodes', async () => {\n      // Add test nodes\n      syncSystem.addNode({\n        id: 'node-1',\n        address: '127.0.0.1',\n        port: 8001,\n        memoryUsage: 0,\n        entryCount: 0\n      });\n\n      syncSystem.addNode({\n        id: 'node-2',\n        address: '127.0.0.1',\n        port: 8002,\n        memoryUsage: 0,\n        entryCount: 0\n      });\n\n      const nodes = syncSystem.getNodes();\n      expect(nodes).toHaveLength(2);\n      expect(nodes[0].id).toBe('node-1');\n      expect(nodes[1].id).toBe('node-2');\n    });\n\n    test('should handle heartbeat messages', async () => {\n      syncSystem.addNode({\n        id: 'heartbeat-node',\n        address: '127.0.0.1',\n        port: 8003,\n        memoryUsage: 0,\n        entryCount: 0\n      });\n\n      const heartbeatMessage = {\n        id: 'hb-1',\n        type: 'heartbeat' as const,\n        sourceNodeId: 'heartbeat-node',\n        payload: {\n          memoryUsage: 1024,\n          entryCount: 10,\n          vectorClock: {}\n        },\n        timestamp: Date.now(),\n        version: 1\n      };\n\n      syncSystem.processHeartbeat(heartbeatMessage);\n\n      const nodes = syncSystem.getNodes();\n      const heartbeatNode = nodes.find(n => n.id === 'heartbeat-node');\n      \n      expect(heartbeatNode).toBeDefined();\n      expect(heartbeatNode!.status).toBe('online');\n      expect(heartbeatNode!.memoryUsage).toBe(1024);\n      expect(heartbeatNode!.entryCount).toBe(10);\n    });\n\n    test('should synchronize data across nodes', async () => {\n      // Add test data to memory manager\n      const testData = {\n        syncTest: true,\n        data: 'test synchronization'\n      };\n\n      await memoryManager.store('sync-test', testData, 'default');\n\n      // Add nodes\n      syncSystem.addNode({\n        id: 'sync-node-1',\n        address: '127.0.0.1',\n        port: 8004,\n        memoryUsage: 0,\n        entryCount: 0\n      });\n\n      // Simulate node coming online\n      syncSystem.processHeartbeat({\n        id: 'hb-sync-1',\n        type: 'heartbeat',\n        sourceNodeId: 'sync-node-1',\n        payload: { memoryUsage: 0, entryCount: 0, vectorClock: {} },\n        timestamp: Date.now(),\n        version: 1\n      });\n\n      // Trigger synchronization\n      await syncSystem.synchronizeAll();\n\n      const metrics = syncSystem.getMetrics();\n      expect(metrics.totalSyncOperations).toBeGreaterThan(0);\n    });\n  });\n\n  describe('Performance and Load Testing', () => {\n    test('should handle concurrent memory operations', async () => {\n      const promises = [];\n      const dataCount = 100;\n\n      // Store data concurrently\n      for (let i = 0; i < dataCount; i++) {\n        const promise = memoryManager.store(`concurrent-${i}`, { id: i, data: `data-${i}` }, 'default');\n        promises.push(promise);\n      }\n\n      const results = await Promise.all(promises);\n      \n      // All operations should succeed (or handle gracefully)\n      const successCount = results.filter(r => r === true).length;\n      expect(successCount).toBeGreaterThan(0);\n\n      const stats = memoryManager.getStats();\n      expect(stats.entryCount).toBeGreaterThan(0);\n    });\n\n    test('should maintain performance under load', async () => {\n      const operationCount = 1000;\n      const startTime = Date.now();\n\n      // Perform mixed operations\n      for (let i = 0; i < operationCount; i++) {\n        if (i % 3 === 0) {\n          await memoryManager.store(`perf-${i}`, { data: `performance-test-${i}` }, 'default');\n        } else if (i % 3 === 1) {\n          await memoryManager.retrieve(`perf-${i - 1}`);\n        } else {\n          await memoryManager.remove(`perf-${i - 2}`);\n        }\n      }\n\n      const endTime = Date.now();\n      const totalTime = endTime - startTime;\n      const avgOperationTime = totalTime / operationCount;\n\n      // Should complete within reasonable time (< 1ms per operation)\n      expect(avgOperationTime).toBeLessThan(1);\n    });\n\n    test('should handle memory pressure gracefully', async () => {\n      // Fill memory to near capacity\n      let i = 0;\n      let lastSuccess = true;\n      \n      while (lastSuccess && i < 10000) {\n        const data = { id: i, content: 'x'.repeat(1000) }; // 1KB each\n        lastSuccess = await memoryManager.store(`pressure-${i}`, data, 'default');\n        i++;\n      }\n\n      const stats = memoryManager.getStats();\n      \n      // Should stay within memory limits\n      expect(stats.totalSize).toBeLessThanOrEqual(10 * 1024 * 1024);\n      \n      // Should still be functional\n      const testData = { test: 'memory pressure test' };\n      const stored = await memoryManager.store('pressure-test', testData, 'default');\n      \n      if (stored) {\n        const retrieved = await memoryManager.retrieve('pressure-test');\n        expect(retrieved).toEqual(testData);\n      }\n    });\n  });\n\n  describe('Error Handling and Edge Cases', () => {\n    test('should handle invalid data gracefully', async () => {\n      // Test with circular reference\n      const circularRef: any = { name: 'circular' };\n      circularRef.self = circularRef;\n\n      await expect(async () => {\n        await memoryManager.store('circular', circularRef, 'default');\n      }).not.toThrow();\n    });\n\n    test('should handle unregistered Princess operations', async () => {\n      await expect(async () => {\n        await coordinator.store('non-existent-princess', 'test-key', { data: 'test' });\n      }).rejects.toThrow('Princess non-existent-princess not found');\n\n      await expect(async () => {\n        await coordinator.retrieve('non-existent-princess', 'test-key');\n      }).rejects.toThrow('Princess non-existent-princess not found');\n    });\n\n    test('should handle maximum Princess limit', async () => {\n      // Register maximum number of Princesses (6)\n      for (let i = 1; i <= 6; i++) {\n        await coordinator.registerPrincess({\n          principalId: `princess-${i}`,\n          domain: `domain-${i}`,\n          maxMemorySize: 10 * 1024 * 1024,\n          partitionIds: [`partition-${i}`],\n          priority: 1,\n          enableSharing: false,\n          enableVersioning: false\n        });\n      }\n\n      // Attempt to register 7th Princess should fail\n      await expect(async () => {\n        await coordinator.registerPrincess({\n          principalId: 'princess-7',\n          domain: 'domain-7',\n          maxMemorySize: 10 * 1024 * 1024,\n          partitionIds: ['partition-7'],\n          priority: 1,\n          enableSharing: false,\n          enableVersioning: false\n        });\n      }).rejects.toThrow('Maximum number of Princesses');\n    });\n\n    test('should handle memory corruption scenarios', async () => {\n      // Store valid data\n      await memoryManager.store('valid-key', { data: 'valid' }, 'default');\n      \n      // Simulate memory corruption by direct manipulation\n      // In a real scenario, this might happen due to hardware issues\n      \n      // The system should handle this gracefully\n      const retrieved = await memoryManager.retrieve('valid-key');\n      \n      // Should either return the data or null, but not crash\n      expect(retrieved === null || typeof retrieved === 'object').toBe(true);\n    });\n  });\n});"