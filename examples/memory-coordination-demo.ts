#!/usr/bin/env ts-node

/**
 * Cross-Princess Memory Coordination Demo
 *
 * This example demonstrates the complete 10MB Langroid memory system
 * with cross-Princess coordination, real-time synchronization, and
 * comprehensive analytics.
 */

import { CrossPrincessMemoryCoordinator } from '../src/memory/coordination/CrossPrincessMemoryCoordinator';
import { MemoryUsageAnalyzer } from '../src/memory/analytics/MemoryUsageAnalyzer';
import { LangroidMemoryManager } from '../src/memory/langroid/LangroidMemoryManager';\n\n// Color utilities for console output\nconst colors = {\n  reset: '\\x1b[0m',\n  bright: '\\x1b[1m',\n  red: '\\x1b[31m',\n  green: '\\x1b[32m',\n  yellow: '\\x1b[33m',\n  blue: '\\x1b[34m',\n  magenta: '\\x1b[35m',\n  cyan: '\\x1b[36m'\n};\n\nfunction log(message: string, color: keyof typeof colors = 'reset') {\n  console.log(`${colors[color]}${message}${colors.reset}`);\n}\n\nfunction formatBytes(bytes: number): string {\n  if (bytes === 0) return '0 B';\n  const k = 1024;\n  const sizes = ['B', 'KB', 'MB', 'GB'];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(2))} ${sizes[i]}`;\n}\n\nfunction formatPercentage(value: number): string {\n  return `${(value * 100).toFixed(1)}%`;\n}\n\nclass MemoryCoordinationDemo {\n  private coordinator: CrossPrincessMemoryCoordinator;\n  private analyzer: MemoryUsageAnalyzer;\n  private demoData: Map<string, any> = new Map();\n\n  constructor() {\n    this.coordinator = new CrossPrincessMemoryCoordinator({\n      totalMemoryLimit: 60 * 1024 * 1024, // 60MB total\n      princessMemoryLimit: 10 * 1024 * 1024, // 10MB per Princess\n      enableConflictResolution: true,\n      enableLoadBalancing: true\n    });\n\n    // Create a memory manager for analysis\n    const analysisMemoryManager = new LangroidMemoryManager({\n      maxSizeBytes: 10 * 1024 * 1024\n    });\n\n    this.analyzer = new MemoryUsageAnalyzer(analysisMemoryManager, {\n      enableRealTimeAnalysis: true,\n      enablePredictiveAnalysis: true\n    });\n\n    this.setupEventListeners();\n    this.generateDemoData();\n  }\n\n  /**\n   * Setup event listeners for monitoring\n   */\n  private setupEventListeners(): void {\n    this.coordinator.on('princess_registered', (data) => {\n      log(` Princess ${data.principalId} (${data.domain}) registered`, 'green');\n    });\n\n    this.coordinator.on('memory_transferred', (data) => {\n      log(` Transferred ${data.transferredCount} entries from ${data.fromPrincess} to ${data.toPrincess}`, 'cyan');\n    });\n\n    this.coordinator.on('sync_completed', (data) => {\n      log(` Sync ${data.syncId} completed in ${data.operation.endTime! - data.operation.startTime}ms`, 'blue');\n    });\n\n    this.coordinator.on('load_balanced', (data) => {\n      log(`  Load balanced: ${data.entriesTransferred} entries from ${data.from} to ${data.to}`, 'yellow');\n    });\n\n    this.analyzer.on('analysis_completed', (data) => {\n      log(` Memory analysis completed (Score: ${data.report.overallScore.toFixed(1)}/100)`, 'magenta');\n    });\n  }\n\n  /**\n   * Generate demo data for testing\n   */\n  private generateDemoData(): void {\n    // Architecture data\n    this.demoData.set('arch_system_design', {\n      components: ['API Gateway', 'User Service', 'Payment Service'],\n      patterns: ['Microservices', 'Event Sourcing', 'CQRS'],\n      technologies: ['Node.js', 'PostgreSQL', 'Redis'],\n      lastUpdated: Date.now()\n    });\n\n    // Development data\n    this.demoData.set('dev_active_features', {\n      features: ['User Authentication', 'Payment Processing', 'Notification System'],\n      branches: ['feature/auth', 'feature/payments', 'feature/notifications'],\n      activeDevs: ['Alice', 'Bob', 'Charlie'],\n      lastCommit: Date.now()\n    });\n\n    // Documentation data\n    this.demoData.set('docs_api_specs', {\n      endpoints: ['/api/users', '/api/payments', '/api/notifications'],\n      schemas: ['User', 'Payment', 'Notification'],\n      examples: ['curl examples', 'SDK usage', 'Postman collections'],\n      version: '2.1.0'\n    });\n\n    // Infrastructure data\n    this.demoData.set('infra_deployment_config', {\n      environments: ['development', 'staging', 'production'],\n      resources: ['ECS Clusters', 'RDS Instances', 'ElastiCache'],\n      monitoring: ['CloudWatch', 'DataDog', 'Grafana'],\n      lastDeployment: Date.now()\n    });\n\n    // Performance data\n    this.demoData.set('perf_metrics', {\n      responseTime: 150,\n      throughput: 1000,\n      errorRate: 0.01,\n      availability: 99.95,\n      timestamp: Date.now()\n    });\n\n    // Quality data\n    this.demoData.set('quality_test_results', {\n      unitTests: { passed: 245, failed: 3, coverage: 89.5 },\n      integrationTests: { passed: 67, failed: 1, coverage: 76.2 },\n      e2eTests: { passed: 23, failed: 0, coverage: 65.8 },\n      lastRun: Date.now()\n    });\n\n    // Research data\n    this.demoData.set('research_findings', {\n      technologies: ['GraphQL Federation', 'Event Mesh', 'Service Mesh'],\n      benchmarks: ['Performance comparisons', 'Scalability tests'],\n      recommendations: ['Adopt GraphQL', 'Implement Event Mesh'],\n      lastUpdated: Date.now()\n    });\n\n    // Security data\n    this.demoData.set('security_scan_results', {\n      vulnerabilities: { critical: 0, high: 2, medium: 5, low: 12 },\n      compliance: { score: 95, frameworks: ['SOC2', 'GDPR', 'HIPAA'] },\n      lastScan: Date.now()\n    });\n\n    log(` Generated ${this.demoData.size} demo data entries`, 'green');\n  }\n\n  /**\n   * Register all 6 domain Princesses\n   */\n  async registerPrincesses(): Promise<void> {\n    log('\\n Registering Domain Princesses...', 'bright');\n\n    const princesses = [\n      {\n        principalId: 'architecture-princess',\n        domain: 'architecture',\n        partitionIds: ['architecture', 'shared'],\n        priority: 1,\n        cacheStrategy: 'lru'\n      },\n      {\n        principalId: 'development-princess',\n        domain: 'development',\n        partitionIds: ['development', 'shared'],\n        priority: 2,\n        cacheStrategy: 'adaptive-lru'\n      },\n      {\n        principalId: 'documentation-princess',\n        domain: 'documentation',\n        partitionIds: ['documentation', 'shared'],\n        priority: 4,\n        cacheStrategy: 'lfu'\n      },\n      {\n        principalId: 'infrastructure-princess',\n        domain: 'infrastructure',\n        partitionIds: ['infrastructure', 'shared'],\n        priority: 3,\n        cacheStrategy: 'ttl'\n      },\n      {\n        principalId: 'performance-princess',\n        domain: 'performance',\n        partitionIds: ['performance', 'shared'],\n        priority: 2,\n        cacheStrategy: 'largest-first'\n      },\n      {\n        principalId: 'quality-princess',\n        domain: 'quality',\n        partitionIds: ['quality', 'shared'],\n        priority: 1,\n        cacheStrategy: 'adaptive-lru'\n      },\n      {\n        principalId: 'research-princess',\n        domain: 'research',\n        partitionIds: ['research', 'shared'],\n        priority: 3,\n        cacheStrategy: 'lru'\n      },\n      {\n        principalId: 'security-princess',\n        domain: 'security',\n        partitionIds: ['security', 'shared'],\n        priority: 1,\n        cacheStrategy: 'adaptive-lru'\n      }\n    ];\n\n    for (const config of princesses.slice(0, 6)) { // Register only 6 (max limit)\n      await this.coordinator.registerPrincess({\n        ...config,\n        maxMemorySize: 10 * 1024 * 1024, // 10MB each\n        enableSharing: true,\n        enableVersioning: true\n      });\n      \n      // Small delay for demonstration\n      await new Promise(resolve => setTimeout(resolve, 100));\n    }\n\n    log(' All Princesses registered successfully\\n', 'green');\n  }\n\n  /**\n   * Populate Princess memories with demo data\n   */\n  async populateMemories(): Promise<void> {\n    log(' Populating Princess memories with demo data...', 'bright');\n\n    const dataMapping = {\n      'architecture-princess': ['arch_system_design'],\n      'development-princess': ['dev_active_features'],\n      'documentation-princess': ['docs_api_specs'],\n      'infrastructure-princess': ['infra_deployment_config'],\n      'performance-princess': ['perf_metrics'],\n      'quality-princess': ['quality_test_results']\n    };\n\n    for (const [principalId, dataKeys] of Object.entries(dataMapping)) {\n      for (const key of dataKeys) {\n        const data = this.demoData.get(key);\n        if (data) {\n          await this.coordinator.store(principalId, key, data);\n          log(`   Stored ${key} in ${principalId}`, 'cyan');\n        }\n      }\n    }\n\n    // Add some shared data\n    const sharedData = {\n      project_config: {\n        name: 'SPEK Platform',\n        version: '2.0.0',\n        environment: 'production',\n        features: ['memory-coordination', 'real-time-sync', 'analytics']\n      },\n      system_status: {\n        health: 'healthy',\n        uptime: '99.95%',\n        activeUsers: 1250,\n        lastUpdate: Date.now()\n      }\n    };\n\n    for (const [key, data] of Object.entries(sharedData)) {\n      await this.coordinator.store('architecture-princess', key, data, 'shared');\n      log(`   Stored shared data: ${key}`, 'yellow');\n    }\n\n    log(' Memory population completed\\n', 'green');\n  }\n\n  /**\n   * Demonstrate memory retrieval across Princesses\n   */\n  async demonstrateRetrieval(): Promise<void> {\n    log(' Demonstrating memory retrieval...', 'bright');\n\n    const retrievalTests = [\n      { principalId: 'architecture-princess', key: 'arch_system_design' },\n      { principalId: 'development-princess', key: 'dev_active_features' },\n      { principalId: 'quality-princess', key: 'quality_test_results' },\n      { principalId: 'architecture-princess', key: 'project_config' } // Shared data\n    ];\n\n    for (const test of retrievalTests) {\n      const startTime = Date.now();\n      const data = await this.coordinator.retrieve(test.principalId, test.key);\n      const retrievalTime = Date.now() - startTime;\n\n      if (data) {\n        const dataSize = JSON.stringify(data).length;\n        log(`   Retrieved ${test.key} from ${test.principalId} (${formatBytes(dataSize)}, ${retrievalTime}ms)`, 'green');\n      } else {\n        log(`   Failed to retrieve ${test.key} from ${test.principalId}`, 'red');\n      }\n    }\n\n    log('\\n');\n  }\n\n  /**\n   * Demonstrate memory transfer between Princesses\n   */\n  async demonstrateTransfer(): Promise<void> {\n    log(' Demonstrating memory transfer...', 'bright');\n\n    // Transfer research data to documentation princess\n    await this.coordinator.store('research-princess', 'research_findings', this.demoData.get('research_findings'));\n    \n    const transferRequest = {\n      fromPrincess: 'research-princess',\n      toPrincess: 'documentation-princess',\n      keys: ['research_findings'],\n      preserveOriginal: false,\n      priority: 1\n    };\n\n    const success = await this.coordinator.transferMemory(transferRequest);\n    \n    if (success) {\n      log('   Memory transfer completed successfully', 'green');\n      \n      // Verify transfer\n      const data = await this.coordinator.retrieve('documentation-princess', 'research_findings');\n      if (data) {\n        log('   Transfer verified - data accessible from target Princess', 'green');\n      }\n    } else {\n      log('   Memory transfer failed', 'red');\n    }\n\n    log('\\n');\n  }\n\n  /**\n   * Demonstrate synchronization across all Princesses\n   */\n  async demonstrateSynchronization(): Promise<void> {\n    log(' Demonstrating cross-Princess synchronization...', 'bright');\n\n    const syncId = await this.coordinator.synchronizeAll('full');\n    log(`   Full synchronization initiated: ${syncId}`, 'cyan');\n\n    // Wait for sync to complete\n    await new Promise(resolve => setTimeout(resolve, 2000));\n\n    log('   Synchronization completed', 'green');\n    log('\\n');\n  }\n\n  /**\n   * Display Princess status information\n   */\n  displayPrincessStatuses(): void {\n    log(' Princess Memory Status Report', 'bright');\n    log(''.repeat(60), 'blue');\n\n    const statuses = this.coordinator.getPrincessStatuses();\n\n    for (const status of statuses) {\n      const healthIcon = status.isHealthy ? '' : '';\n      const utilizationColor = status.utilizationPercentage > 80 ? 'red' : \n                              status.utilizationPercentage > 60 ? 'yellow' : 'green';\n\n      log(`\\n${healthIcon} ${status.domain.toUpperCase()} PRINCESS (${status.principalId})`, 'cyan');\n      log(`   Memory: ${formatBytes(status.memoryUsage)} / ${formatBytes(status.memoryLimit)} (${formatPercentage(status.utilizationPercentage / 100)})`, utilizationColor);\n      log(`   Entries: ${status.entryCount}`, 'reset');\n      log(`   Cache Hit Rate: ${formatPercentage(status.cacheHitRate)}`, 'reset');\n      log(`   Last Sync: ${new Date(status.lastSync).toLocaleTimeString()}`, 'reset');\n      log(`   Conflicts: ${status.conflictCount}`, 'reset');\n    }\n\n    log('\\n'.repeat(60), 'blue');\n  }\n\n  /**\n   * Display coordinator metrics\n   */\n  displayCoordinatorMetrics(): void {\n    log(' Memory Coordinator Metrics', 'bright');\n    log(''.repeat(50), 'blue');\n\n    const metrics = this.coordinator.getMetrics();\n\n    log(`Total Memory Used: ${formatBytes(metrics.totalMemoryUsed)} / ${formatBytes(metrics.totalMemoryLimit)}`, 'cyan');\n    log(`Memory Utilization: ${formatPercentage(metrics.totalMemoryUsed / metrics.totalMemoryLimit)}`, 'cyan');\n    log(`Active Princesses: ${metrics.activePrincesses}`, 'green');\n    log(`Total Sync Operations: ${metrics.totalSyncOperations}`, 'yellow');\n    log(`Total Conflicts Resolved: ${metrics.totalConflicts}`, 'magenta');\n    log(`Average Response Time: ${metrics.averageResponseTime.toFixed(2)}ms`, 'reset');\n    log(`System Health: ${formatPercentage(metrics.systemHealth)}`, metrics.systemHealth > 0.8 ? 'green' : metrics.systemHealth > 0.6 ? 'yellow' : 'red');\n\n    log(''.repeat(50), 'blue');\n    log('\\n');\n  }\n\n  /**\n   * Run memory analysis and display results\n   */\n  async runMemoryAnalysis(): Promise<void> {\n    log(' Running Memory Usage Analysis...', 'bright');\n\n    try {\n      const report = await this.analyzer.analyze();\n\n      log(''.repeat(60), 'blue');\n      log(` MEMORY ANALYSIS REPORT`, 'cyan');\n      log(`   Generated: ${new Date(report.timestamp).toLocaleString()}`, 'reset');\n      log(`   Overall Score: ${report.overallScore.toFixed(1)}/100`, report.overallScore > 80 ? 'green' : report.overallScore > 60 ? 'yellow' : 'red');\n      log(''.repeat(60), 'blue');\n\n      // Usage Patterns\n      if (report.usagePatterns.length > 0) {\n        log('\\n USAGE PATTERNS:', 'yellow');\n        report.usagePatterns.forEach(pattern => {\n          log(`   ${pattern.patternType}: ${pattern.description} (${formatPercentage(pattern.confidence)} confidence)`, 'reset');\n          pattern.recommendations.slice(0, 2).forEach(rec => {\n            log(`      ${rec}`, 'cyan');\n          });\n        });\n      }\n\n      // Trends\n      if (report.trends.length > 0) {\n        log('\\n MEMORY TRENDS:', 'yellow');\n        report.trends.forEach(trend => {\n          const trendIcon = trend.trend === 'increasing' ? '' : \n                           trend.trend === 'decreasing' ? '' : \n                           trend.trend === 'stable' ? '' : '';\n          log(`   ${trendIcon} ${trend.metric}: ${trend.trend} (${trend.changeRate.toFixed(2)} rate)`, 'reset');\n        });\n      }\n\n      // Optimization Opportunities\n      if (report.optimizationOpportunities.length > 0) {\n        log('\\n OPTIMIZATION OPPORTUNITIES:', 'yellow');\n        report.optimizationOpportunities.forEach(opp => {\n          const priorityColor = opp.priority === 'critical' ? 'red' : \n                               opp.priority === 'high' ? 'yellow' : 'green';\n          log(`   ${opp.type.toUpperCase()} (${opp.priority}): ${opp.description}`, priorityColor);\n          log(`     Potential Savings: ${formatBytes(opp.potentialSavings)}`, 'cyan');\n        });\n      }\n\n      // Top Recommendations\n      if (report.recommendations.length > 0) {\n        log('\\n TOP RECOMMENDATIONS:', 'yellow');\n        report.recommendations.slice(0, 5).forEach((rec, index) => {\n          log(`   ${index + 1}. ${rec}`, 'green');\n        });\n      }\n\n      log(''.repeat(60), 'blue');\n      log('\\n');\n\n    } catch (error) {\n      log(` Analysis failed: ${error.message}`, 'red');\n    }\n  }\n\n  /**\n   * Simulate load balancing scenario\n   */\n  async simulateLoadBalancing(): Promise<void> {\n    log('  Simulating load balancing scenario...', 'bright');\n\n    // Add extra data to one Princess to trigger load balancing\n    const heavyData = {\n      large_dataset: {\n        entries: Array.from({ length: 1000 }, (_, i) => ({ id: i, data: `entry_${i}`, timestamp: Date.now() })),\n        metadata: { size: 'large', purpose: 'demonstration' }\n      }\n    };\n\n    await this.coordinator.store('development-princess', 'large_dataset', heavyData);\n    log('   Added large dataset to Development Princess', 'cyan');\n\n    // Trigger load balancing\n    await this.coordinator.loadBalance();\n    log('    Load balancing completed', 'green');\n\n    log('\\n');\n  }\n\n  /**\n   * Run the complete demonstration\n   */\n  async run(): Promise<void> {\n    try {\n      log(' Starting Cross-Princess Memory Coordination Demo', 'bright');\n      log('', 'blue');\n\n      // Step 1: Register Princesses\n      await this.registerPrincesses();\n\n      // Step 2: Populate memories\n      await this.populateMemories();\n\n      // Step 3: Demonstrate retrieval\n      await this.demonstrateRetrieval();\n\n      // Step 4: Demonstrate transfer\n      await this.demonstrateTransfer();\n\n      // Step 5: Demonstrate synchronization\n      await this.demonstrateSynchronization();\n\n      // Step 6: Display status\n      this.displayPrincessStatuses();\n      this.displayCoordinatorMetrics();\n\n      // Step 7: Run analysis\n      await this.runMemoryAnalysis();\n\n      // Step 8: Simulate load balancing\n      await this.simulateLoadBalancing();\n\n      // Final status\n      log(' Final Status Check', 'bright');\n      this.displayPrincessStatuses();\n      this.displayCoordinatorMetrics();\n\n      log(' Demo completed successfully!', 'green');\n      log('', 'blue');\n\n    } catch (error) {\n      log(` Demo failed: ${error.message}`, 'red');\n      console.error(error);\n    } finally {\n      // Cleanup\n      await this.cleanup();\n    }\n  }\n\n  /**\n   * Cleanup resources\n   */\n  private async cleanup(): Promise<void> {\n    log('\\n Cleaning up resources...', 'yellow');\n    \n    await this.analyzer.shutdown();\n    await this.coordinator.shutdown();\n    \n    log(' Cleanup completed', 'green');\n  }\n}\n\n// Run the demo if this file is executed directly\nif (require.main === module) {\n  const demo = new MemoryCoordinationDemo();\n  demo.run().catch(console.error);\n}\n\nexport { MemoryCoordinationDemo };"