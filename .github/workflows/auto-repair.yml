name: Enhanced Auto-Repair with Closed-Loop Integration
on:
  workflow_run:
    workflows: ["Enhanced Quality Gates", "Quality Analysis Orchestrator", "CodeQL Analysis", "Security Scan"]
    types: [completed]
  workflow_dispatch:
    inputs:
      repair_mode:
        description: 'Auto-repair execution mode'
        required: false
        default: 'automatic'
        type: choice
        options:
          - automatic
          - supervised
          - analysis_only
      target_workflow:
        description: 'Target workflow for repair (leave empty for auto-detection)'
        required: false
        type: string

env:
  PYTHON_VERSION: '3.12'
  NODE_VERSION: '20'
  REPAIR_MODE: ${{ github.event.inputs.repair_mode || 'automatic' }}

jobs:
  intelligent_repair_orchestrator:
    if: ${{ github.event.workflow_run.conclusion == 'failure' || github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest-4-core
    name: "Intelligent Auto-Repair with Closed-Loop Integration"
    timeout-minutes: 45
    permissions:
      contents: write
      pull-requests: write
      checks: write
      actions: read
      issues: write

    outputs:
      repair_status: ${{ steps.repair_execution.outputs.repair_status }}
      actions_taken: ${{ steps.repair_execution.outputs.actions_taken }}
      success_rate: ${{ steps.repair_execution.outputs.success_rate }}

    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0

    - name: Setup Development Environment
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    - uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        cache: 'pip'

    - name: Install Enhanced Repair Dependencies
      run: |
        echo "Installing comprehensive auto-repair and GitHub integration dependencies..."
        
        # Python dependencies for repair and GitHub integration
        pip install --upgrade pip
        pip install PyGithub ghapi requests pyyaml python-dateutil
        
        # Code quality and repair tools
        pip install black isort autoflake safety bandit semgrep
        pip install pre-commit autopep8 flake8
        
        # Analysis and monitoring tools
        if [ -f requirements.txt ]; then
          pip install -r requirements.txt
        fi
        
        # Install analyzer if available
        pip install -e ./analyzer 2>/dev/null || echo "Analyzer not available for installation"
        
        # Node.js dependencies if package.json exists
        if [ -f package.json ]; then
          npm ci || npm install
          echo "Node.js dependencies installed"
        fi
        
        # Verify GitHub integration script
        if [ -f scripts/github_integration.py ]; then
          echo "GitHub integration script found - testing import..."
          python -c "
          import sys
          sys.path.append('.')
          try:
              from scripts.github_integration import GitHubIntegration
              print('[OK] GitHub integration available')
          except ImportError as e:
              print(f'[WARNING] GitHub integration import failed: {e}')
          "
        fi

    - name: Download Failed Workflow Artifacts
      uses: actions/download-artifact@v4
      with:
        name: quality-gates-artifacts
        path: .claude/.artifacts/
      continue-on-error: true

    - name: Download Enhanced Quality Gate Artifacts
      uses: actions/download-artifact@v4
      with:
        path: ./workflow-artifacts
        merge-multiple: true
      continue-on-error: true

    - name: Initialize Closed-Loop Integration
      id: integration_init
      run: |
        echo "::group::Closed-Loop Integration Initialization"
        echo "Initializing enhanced auto-repair with closed-loop GitHub integration..."
        
        # Create necessary directories
        mkdir -p .github/automation/{reports,recovery,logs}
        mkdir -p .claude/.artifacts/repair
        
        # Load failure recovery configuration
        config_file="configs/failure_recovery.yaml"
        if [ -f "$config_file" ]; then
          echo "Found failure recovery configuration"
          echo "::set-output name=config_loaded::true"
        else
          echo "No failure recovery configuration found - using defaults"
          echo "::set-output name=config_loaded::false"
        fi
        
        # Detect failed workflow context
        if [ "${{ github.event_name }}" == "workflow_run" ]; then
          failed_workflow="${{ github.event.workflow_run.name }}"
          workflow_conclusion="${{ github.event.workflow_run.conclusion }}"
          workflow_id="${{ github.event.workflow_run.id }}"
          
          echo "Triggered by workflow failure:"
          echo "  - Workflow: $failed_workflow"
          echo "  - Conclusion: $workflow_conclusion"
          echo "  - Run ID: $workflow_id"
          
          echo "::set-output name=failed_workflow::$failed_workflow"
          echo "::set-output name=trigger_mode::workflow_failure"
        else
          echo "Manually triggered repair mode"
          echo "::set-output name=trigger_mode::manual"
        fi
        
        echo "::endgroup::"

    - name: Execute Intelligent Failure Analysis
      id: failure_analysis
      run: |
        echo "::group::Intelligent Failure Analysis with GitHub Integration"
        echo "Analyzing failures using closed-loop GitHub integration system..."
        
        python -c "
        import os
        import sys
        import json
        import asyncio
        from datetime import datetime
        from pathlib import Path
        
        # Add current directory to path for imports
        sys.path.insert(0, '.')
        
        async def execute_failure_analysis():
            print('[SEARCH] INTELLIGENT FAILURE ANALYSIS SYSTEM')
            print('=' * 50)
            
            # Initialize analysis results
            analysis_results = {
                'timestamp': datetime.now().isoformat(),
                'trigger_mode': os.environ.get('trigger_mode', 'unknown'),
                'failed_workflow': os.environ.get('failed_workflow', 'unknown'),
                'analysis_summary': {},
                'recommendations': [],
                'repair_strategy': 'automatic'
            }
            
            try:
                # Try to use GitHub integration if available
                try:
                    from scripts.github_integration import GitHubIntegration, FailureCategory
                    
                    print('[OK] GitHub integration available - performing advanced analysis')
                    github_integration = GitHubIntegration()
                    
                    # Perform comprehensive failure analysis
                    failure_analysis = await github_integration.analyze_failures(lookback_hours=24)
                    
                    # Convert analysis to serializable format
                    analysis_results['failure_analysis'] = {
                        'failure_detected': failure_analysis.failure_detected,
                        'failure_category': failure_analysis.failure_category.value,
                        'failure_rate': failure_analysis.failure_rate,
                        'recovery_priority': failure_analysis.recovery_priority,
                        'recommended_strategy': failure_analysis.recommended_strategy.value,
                        'estimated_recovery_time': failure_analysis.estimated_recovery_time,
                        'recent_failures_count': len(failure_analysis.recent_failures),
                        'failure_patterns': failure_analysis.failure_patterns
                    }
                    
                    print(f'[OK] Advanced failure analysis completed:')
                    print(f'  - Failure detected: {failure_analysis.failure_detected}')
                    print(f'  - Category: {failure_analysis.failure_category.value}')
                    print(f'  - Failure rate: {failure_analysis.failure_rate:.1f}%')
                    print(f'  - Priority: {failure_analysis.recovery_priority}')
                    
                    # Set GitHub Actions outputs
                    print(f'::set-output name=failure_detected::{failure_analysis.failure_detected}')
                    print(f'::set-output name=failure_category::{failure_analysis.failure_category.value}')
                    print(f'::set-output name=recovery_priority::{failure_analysis.recovery_priority}')
                    print(f'::set-output name=repair_strategy::{failure_analysis.recommended_strategy.value}')
                    
                except ImportError as e:
                    print(f'[WARNING] GitHub integration not available: {e}')
                    print('[INFO] Falling back to basic analysis')
                    
                    # Basic failure analysis fallback
                    basic_analysis = perform_basic_analysis()
                    analysis_results['failure_analysis'] = basic_analysis
                    
                    print(f'::set-output name=failure_detected::true')
                    print(f'::set-output name=failure_category::quality_gates')
                    print(f'::set-output name=recovery_priority::medium')
                    print(f'::set-output name=repair_strategy::automatic')
                
                # Analyze available artifacts for repair context
                artifacts_analysis = analyze_available_artifacts()
                analysis_results['artifacts_analysis'] = artifacts_analysis
                
                # Generate repair recommendations
                repair_recommendations = generate_repair_recommendations(analysis_results)
                analysis_results['repair_recommendations'] = repair_recommendations
                
                print(f'\\n[CLIPBOARD] ANALYSIS SUMMARY:')
                print(f'  - Artifacts found: {len(artifacts_analysis.get(\"artifacts\", []))}')
                print(f'  - Repair actions recommended: {len(repair_recommendations)}')
                
            except Exception as e:
                print(f'[ERROR] Analysis execution failed: {e}')
                import traceback
                traceback.print_exc()
                
                # Fallback analysis
                analysis_results['failure_analysis'] = {
                    'failure_detected': True,
                    'failure_category': 'general',
                    'failure_rate': 100.0,
                    'recovery_priority': 'medium',
                    'error': str(e)
                }
            
            # Save analysis results
            with open('.github/automation/failure_analysis.json', 'w') as f:
                json.dump(analysis_results, f, indent=2, default=str)
            
            print(f'\\n[OK] Failure analysis completed and saved')
            return analysis_results
        
        def perform_basic_analysis():
            \"\"\"Basic failure analysis when GitHub integration is unavailable\"\"\"
            print('[INFO] Performing basic failure analysis...')
            
            # Check for common failure indicators
            failure_indicators = []
            
            # Check for test failures
            if Path('.claude/.artifacts').exists():
                artifact_files = list(Path('.claude/.artifacts').glob('**/*.json'))
                failure_indicators.extend([f.name for f in artifact_files])
            
            # Check for workflow artifacts
            if Path('./workflow-artifacts').exists():
                workflow_files = list(Path('./workflow-artifacts').glob('**/*.json'))
                failure_indicators.extend([f.name for f in workflow_files])
            
            return {
                'failure_detected': len(failure_indicators) > 0,
                'failure_category': 'quality_gates',
                'failure_indicators': failure_indicators,
                'analysis_type': 'basic'
            }
        
        def analyze_available_artifacts():
            \"\"\"Analyze available workflow artifacts for repair context\"\"\"
            print('[INFO] Analyzing available artifacts...')
            
            artifacts = []
            
            # Check .claude/.artifacts directory
            if Path('.claude/.artifacts').exists():
                for artifact_file in Path('.claude/.artifacts').glob('**/*'):
                    if artifact_file.is_file():
                        artifacts.append({
                            'path': str(artifact_file),
                            'size': artifact_file.stat().st_size,
                            'type': 'claude_artifact'
                        })
            
            # Check workflow-artifacts directory
            if Path('./workflow-artifacts').exists():
                for artifact_file in Path('./workflow-artifacts').glob('**/*'):
                    if artifact_file.is_file():
                        artifacts.append({
                            'path': str(artifact_file),
                            'size': artifact_file.stat().st_size,
                            'type': 'workflow_artifact'
                        })
            
            return {
                'artifacts': artifacts,
                'total_artifacts': len(artifacts),
                'artifact_types': list(set(a['type'] for a in artifacts))
            }
        
        def generate_repair_recommendations(analysis_results):
            \"\"\"Generate specific repair recommendations based on analysis\"\"\"
            recommendations = []
            
            failure_analysis = analysis_results.get('failure_analysis', {})
            failure_category = failure_analysis.get('failure_category', 'general')
            
            # Category-specific recommendations
            if failure_category == 'quality_gates':
                recommendations.extend([
                    {
                        'action': 'code_formatting',
                        'description': 'Apply automated code formatting fixes',
                        'priority': 'high',
                        'estimated_time_minutes': 5
                    },
                    {
                        'action': 'linting_fixes',
                        'description': 'Fix common linting issues',
                        'priority': 'high', 
                        'estimated_time_minutes': 10
                    },
                    {
                        'action': 'unused_code_cleanup',
                        'description': 'Remove unused imports and variables',
                        'priority': 'medium',
                        'estimated_time_minutes': 5
                    }
                ])
            
            elif failure_category == 'security':
                recommendations.extend([
                    {
                        'action': 'security_scan',
                        'description': 'Run comprehensive security analysis',
                        'priority': 'critical',
                        'estimated_time_minutes': 15
                    },
                    {
                        'action': 'dependency_audit',
                        'description': 'Audit dependencies for vulnerabilities',
                        'priority': 'high',
                        'estimated_time_minutes': 10
                    }
                ])
            
            elif failure_category == 'dependencies':
                recommendations.extend([
                    {
                        'action': 'dependency_check',
                        'description': 'Check for dependency issues and updates',
                        'priority': 'high',
                        'estimated_time_minutes': 15
                    }
                ])
            
            else:
                # General recommendations
                recommendations.extend([
                    {
                        'action': 'general_diagnostic',
                        'description': 'Run general diagnostic checks',
                        'priority': 'medium',
                        'estimated_time_minutes': 10
                    },
                    {
                        'action': 'cache_cleanup', 
                        'description': 'Clear caches that might cause issues',
                        'priority': 'low',
                        'estimated_time_minutes': 5
                    }
                ])
            
            return recommendations
        
        # Execute the analysis
        asyncio.run(execute_failure_analysis())
        "
        
        echo "::endgroup::"

    - name: Execute Intelligent Auto-Repair Actions
      id: repair_execution
      run: |
        echo "::group::Intelligent Auto-Repair Execution"
        echo "Executing intelligent auto-repair actions with closed-loop integration..."
        
        python -c "
        import os
        import sys
        import json
        import asyncio
        import subprocess
        import time
        from datetime import datetime
        from pathlib import Path
        
        sys.path.insert(0, '.')
        
        async def execute_repair_actions():
            print('[WRENCH] INTELLIGENT AUTO-REPAIR EXECUTION SYSTEM')
            print('=' * 55)
            
            # Load failure analysis results
            analysis_file = Path('.github/automation/failure_analysis.json')
            if analysis_file.exists():
                with open(analysis_file, 'r') as f:
                    analysis_data = json.load(f)
                    
                print('[OK] Loaded failure analysis data')
            else:
                print('[WARNING] No failure analysis data found - using defaults')
                analysis_data = {
                    'failure_analysis': {
                        'failure_category': 'quality_gates',
                        'recovery_priority': 'medium'
                    },
                    'repair_recommendations': []
                }
            
            repair_results = {
                'timestamp': datetime.now().isoformat(),
                'repair_mode': os.environ.get('REPAIR_MODE', 'automatic'),
                'actions_attempted': [],
                'actions_successful': [],
                'total_execution_time': 0,
                'overall_success': False
            }
            
            start_time = time.time()
            
            try:
                # Try to use GitHub integration for advanced repair
                try:
                    from scripts.github_integration import GitHubIntegration, FailureAnalysis, FailureCategory, AutomationStrategy
                    
                    print('[OK] GitHub integration available - executing advanced repair')
                    
                    # Reconstruct failure analysis object
                    failure_data = analysis_data.get('failure_analysis', {})
                    
                    # Create minimal FailureAnalysis object for repair execution
                    mock_analysis = type('FailureAnalysis', (), {
                        'failure_detected': failure_data.get('failure_detected', True),
                        'failure_category': FailureCategory(failure_data.get('failure_category', 'quality_gates')),
                        'recovery_priority': failure_data.get('recovery_priority', 'medium'),
                        'recent_failures': [],
                        'failure_patterns': failure_data.get('failure_patterns', {}),
                        'recommended_strategy': AutomationStrategy(failure_data.get('recommended_strategy', 'automatic_retry')),
                        'estimated_recovery_time': failure_data.get('estimated_recovery_time', 15)
                    })()
                    
                    # Execute recovery actions
                    github_integration = GitHubIntegration()
                    recovery_actions = await github_integration.execute_recovery_actions(
                        mock_analysis, recovery_mode=os.environ.get('REPAIR_MODE', 'automatic')
                    )
                    
                    # Process recovery results
                    for action in recovery_actions:
                        repair_results['actions_attempted'].append({
                            'action_type': action.action_type,
                            'description': action.description,
                            'status': action.status,
                            'success': action.success,
                            'execution_time': action.execution_time
                        })
                        
                        if action.success:
                            repair_results['actions_successful'].append(action.action_type)
                    
                    print(f'[OK] Advanced repair execution completed with {len(recovery_actions)} actions')
                    
                except ImportError as e:
                    print(f'[WARNING] Advanced repair not available: {e}')
                    print('[INFO] Falling back to basic repair actions')
                    
                    # Execute basic repair actions
                    basic_actions = await execute_basic_repair_actions()
                    repair_results['actions_attempted'] = basic_actions
                    repair_results['actions_successful'] = [a['action_type'] for a in basic_actions if a['success']]
                
                # Calculate overall success
                total_actions = len(repair_results['actions_attempted'])
                successful_actions = len(repair_results['actions_successful'])
                success_rate = (successful_actions / max(total_actions, 1)) * 100
                
                repair_results['total_actions'] = total_actions
                repair_results['successful_actions'] = successful_actions
                repair_results['success_rate'] = success_rate
                repair_results['overall_success'] = success_rate >= 50  # 50% threshold
                
                # Determine repair status
                if success_rate >= 75:
                    repair_status = 'successful'
                elif success_rate >= 50:
                    repair_status = 'partially_successful'
                else:
                    repair_status = 'failed'
                
                repair_results['repair_status'] = repair_status
                
            except Exception as e:
                print(f'[ERROR] Repair execution failed: {e}')
                import traceback
                traceback.print_exc()
                
                repair_results['error'] = str(e)
                repair_results['repair_status'] = 'failed'
            
            # Calculate total execution time
            repair_results['total_execution_time'] = time.time() - start_time
            
            # Save repair results
            with open('.github/automation/repair_results.json', 'w') as f:
                json.dump(repair_results, f, indent=2, default=str)
            
            # Set GitHub Actions outputs
            print(f'::set-output name=repair_status::{repair_results[\"repair_status\"]}')
            print(f'::set-output name=actions_taken::{repair_results[\"total_actions\"]}')
            print(f'::set-output name=success_rate::{repair_results[\"success_rate\"]:.1f}')
            
            print(f'\\n[CHART] REPAIR EXECUTION SUMMARY:')
            print(f'  - Status: {repair_results[\"repair_status\"]}')
            print(f'  - Actions attempted: {repair_results[\"total_actions\"]}')
            print(f'  - Actions successful: {repair_results[\"successful_actions\"]}')
            print(f'  - Success rate: {repair_results[\"success_rate\"]:.1f}%')
            print(f'  - Execution time: {repair_results[\"total_execution_time\"]:.2f}s')
            
            return repair_results
        
        async def execute_basic_repair_actions():
            \"\"\"Execute basic repair actions when advanced integration unavailable\"\"\"
            print('[INFO] Executing basic repair actions...')
            
            actions = []
            
            # Action 1: Code formatting
            print('  [ART] Applying code formatting...')
            action_start = time.time()
            
            try:
                # Apply Black formatting to Python files
                result = subprocess.run(['black', '.', '--exclude', 'venv|env|__pycache__'], 
                                      capture_output=True, text=True, timeout=120)
                
                action_time = time.time() - action_start
                
                actions.append({
                    'action_type': 'code_formatting',
                    'description': 'Applied Black code formatting',
                    'success': result.returncode == 0,
                    'execution_time': action_time,
                    'output': result.stdout if result.returncode == 0 else result.stderr
                })
                
                if result.returncode == 0:
                    print('    [OK] Code formatting successful')
                else:
                    print(f'    [FAIL] Code formatting failed: {result.stderr}')
                    
            except Exception as e:
                actions.append({
                    'action_type': 'code_formatting',
                    'description': f'Code formatting failed: {str(e)}',
                    'success': False,
                    'execution_time': time.time() - action_start
                })
                print(f'    [FAIL] Code formatting error: {e}')
            
            # Action 2: Import sorting
            print('  [PACKAGE] Sorting imports...')
            action_start = time.time()
            
            try:
                # Apply isort import sorting
                result = subprocess.run(['isort', '.', '--skip', 'venv', '--skip', 'env'], 
                                      capture_output=True, text=True, timeout=60)
                
                action_time = time.time() - action_start
                
                actions.append({
                    'action_type': 'import_sorting',
                    'description': 'Applied isort import sorting',
                    'success': result.returncode == 0,
                    'execution_time': action_time,
                    'output': result.stdout if result.returncode == 0 else result.stderr
                })
                
                if result.returncode == 0:
                    print('    [OK] Import sorting successful')
                else:
                    print(f'    [FAIL] Import sorting failed: {result.stderr}')
                    
            except Exception as e:
                actions.append({
                    'action_type': 'import_sorting',
                    'description': f'Import sorting failed: {str(e)}',
                    'success': False,
                    'execution_time': time.time() - action_start
                })
                print(f'    [FAIL] Import sorting error: {e}')
            
            # Action 3: Unused code cleanup
            print('  🧹 Cleaning unused code...')
            action_start = time.time()
            
            try:
                # Remove unused imports and variables
                result = subprocess.run(['autoflake', '--remove-all-unused-imports', 
                                       '--remove-unused-variables', '--in-place', '--recursive', '.'], 
                                     capture_output=True, text=True, timeout=120)
                
                action_time = time.time() - action_start
                
                actions.append({
                    'action_type': 'unused_code_cleanup',
                    'description': 'Removed unused imports and variables',
                    'success': result.returncode == 0,
                    'execution_time': action_time,
                    'output': result.stdout if result.returncode == 0 else result.stderr
                })
                
                if result.returncode == 0:
                    print('    [OK] Unused code cleanup successful')
                else:
                    print(f'    [FAIL] Unused code cleanup failed: {result.stderr}')
                    
            except Exception as e:
                actions.append({
                    'action_type': 'unused_code_cleanup',
                    'description': f'Unused code cleanup failed: {str(e)}',
                    'success': False,
                    'execution_time': time.time() - action_start
                })
                print(f'    [FAIL] Unused code cleanup error: {e}')
            
            # Action 4: Cache cleanup
            print('  [DISK] Clearing caches...')
            action_start = time.time()
            
            try:
                # Clear Python cache files
                cache_dirs = ['.pytest_cache', '__pycache__', '.mypy_cache', '.coverage']
                cleared_count = 0
                
                for cache_dir in cache_dirs:
                    cache_path = Path(cache_dir)
                    if cache_path.exists():
                        import shutil
                        shutil.rmtree(cache_path, ignore_errors=True)
                        cleared_count += 1
                
                action_time = time.time() - action_start
                
                actions.append({
                    'action_type': 'cache_cleanup',
                    'description': f'Cleared {cleared_count} cache directories',
                    'success': True,
                    'execution_time': action_time,
                    'cache_dirs_cleared': cleared_count
                })
                
                print(f'    [OK] Cache cleanup successful ({cleared_count} directories)')
                
            except Exception as e:
                actions.append({
                    'action_type': 'cache_cleanup',
                    'description': f'Cache cleanup failed: {str(e)}',
                    'success': False,
                    'execution_time': time.time() - action_start
                })
                print(f'    [FAIL] Cache cleanup error: {e}')
            
            return actions
        
        # Execute repair actions
        asyncio.run(execute_repair_actions())
        "
        
        echo "::endgroup::"

    - name: Commit Automated Fixes
      id: commit_fixes
      if: steps.repair_execution.outputs.repair_status == 'successful' || steps.repair_execution.outputs.repair_status == 'partially_successful'
      run: |
        echo "::group::Committing Automated Fixes"
        echo "Committing automated repair changes..."
        
        # Check if there are any changes to commit
        if git diff --quiet && git diff --staged --quiet; then
          echo "No changes to commit from auto-repair"
          echo "::set-output name=changes_committed::false"
        else
          # Configure git for the action
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action Auto-Repair"
          
          # Stage all changes
          git add .
          
          # Create commit message
          commit_message="🤖 Auto-repair: Fix CI/CD failures with closed-loop automation

Applied automated fixes:
- Actions taken: ${{ steps.repair_execution.outputs.actions_taken }}
- Success rate: ${{ steps.repair_execution.outputs.success_rate }}%
- Repair status: ${{ steps.repair_execution.outputs.repair_status }}

🤖 Generated with [Claude Code](https://claude.ai/code)

Co-Authored-By: Claude <noreply@anthropic.com>"
          
          # Commit changes
          git commit -m "$commit_message"
          
          # Push changes if we're not in a fork
          if [ "${{ github.event.pull_request.head.repo.full_name }}" == "${{ github.repository }}" ] || [ "${{ github.event_name }}" != "pull_request" ]; then
            git push origin HEAD
            echo "Changes pushed to repository"
            echo "::set-output name=changes_committed::true"
          else
            echo "Forked PR detected - changes committed but not pushed"
            echo "::set-output name=changes_committed::true"
          fi
        fi
        
        echo "::endgroup::"

    - name: Update GitHub Status Checks
      id: status_update
      run: |
        echo "::group::GitHub Status Check Updates"
        echo "Updating GitHub status checks with repair results..."
        
        python -c "
        import os
        import sys
        import json
        import requests
        from datetime import datetime
        
        def update_github_status():
            print('📝 GITHUB STATUS CHECK UPDATER')
            print('=' * 40)
            
            # Get environment variables
            github_token = os.environ.get('GITHUB_TOKEN')
            repository = os.environ.get('GITHUB_REPOSITORY')
            commit_sha = os.environ.get('GITHUB_SHA')
            
            if not all([github_token, repository, commit_sha]):
                print('[WARNING] GitHub API credentials incomplete - skipping status updates')
                return
            
            # Load repair results
            repair_file = Path('.github/automation/repair_results.json')
            if repair_file.exists():
                with open(repair_file, 'r') as f:
                    repair_data = json.load(f)
            else:
                print('[WARNING] No repair results found')
                return
            
            # Determine status based on repair results
            repair_status = repair_data.get('repair_status', 'unknown')
            success_rate = repair_data.get('success_rate', 0.0)
            actions_taken = repair_data.get('total_actions', 0)
            
            if repair_status == 'successful':
                state = 'success'
                description = f'Auto-repair successful ({actions_taken} actions, {success_rate:.0f}% success)'
            elif repair_status == 'partially_successful':
                state = 'pending'
                description = f'Partial auto-repair ({actions_taken} actions, {success_rate:.0f}% success)'
            else:
                state = 'failure'
                description = f'Auto-repair failed ({actions_taken} actions, {success_rate:.0f}% success)'
            
            # Create status update
            headers = {
                'Authorization': f'token {github_token}',
                'Accept': 'application/vnd.github.v3+json'
            }
            
            status_data = {
                'state': state,
                'target_url': f'https://github.com/{repository}/actions/runs/{os.environ.get(\"GITHUB_RUN_ID\", \"\")}',
                'description': description,
                'context': 'ci/auto-repair-closed-loop'
            }
            
            status_url = f'https://api.github.com/repos/{repository}/statuses/{commit_sha}'
            
            try:
                response = requests.post(status_url, headers=headers, json=status_data)
                if response.status_code == 201:
                    print(f'[OK] Updated commit status: {state} - {description}')
                else:
                    print(f'[WARNING] Failed to update commit status: {response.status_code}')
            except Exception as e:
                print(f'[WARNING] Status update error: {e}')
            
            print('[OK] Status check update completed')
        
        # Add Path import
        from pathlib import Path
        
        update_github_status()
        "
        
        echo "::endgroup::"

    - name: Generate Comprehensive Repair Report
      id: repair_report
      run: |
        echo "::group::Comprehensive Repair Report Generation"
        echo "Generating comprehensive auto-repair report with closed-loop integration..."
        
        python -c "
        import os
        import json
        from datetime import datetime
        from pathlib import Path
        
        def generate_comprehensive_report():
            print('[CLIPBOARD] COMPREHENSIVE AUTO-REPAIR REPORT GENERATOR')
            print('=' * 55)
            
            # Load all available data
            analysis_file = Path('.github/automation/failure_analysis.json')
            repair_file = Path('.github/automation/repair_results.json')
            
            report_data = {
                'metadata': {
                    'generated_at': datetime.now().isoformat(),
                    'workflow_run_id': os.environ.get('GITHUB_RUN_ID'),
                    'repository': os.environ.get('GITHUB_REPOSITORY'),
                    'commit_sha': os.environ.get('GITHUB_SHA'),
                    'repair_mode': os.environ.get('REPAIR_MODE', 'automatic'),
                    'trigger_mode': 'workflow_failure' if os.environ.get('GITHUB_EVENT_NAME') == 'workflow_run' else 'manual'
                },
                'failure_analysis': {},
                'repair_results': {},
                'summary': {},
                'recommendations': []
            }
            
            # Load failure analysis
            if analysis_file.exists():
                with open(analysis_file, 'r') as f:
                    report_data['failure_analysis'] = json.load(f)
                print('[OK] Loaded failure analysis data')
            
            # Load repair results  
            if repair_file.exists():
                with open(repair_file, 'r') as f:
                    report_data['repair_results'] = json.load(f)
                print('[OK] Loaded repair results data')
            
            # Generate summary
            repair_results = report_data.get('repair_results', {})
            repair_status = repair_results.get('repair_status', 'unknown')
            total_actions = repair_results.get('total_actions', 0)
            successful_actions = repair_results.get('successful_actions', 0)
            success_rate = repair_results.get('success_rate', 0.0)
            
            report_data['summary'] = {
                'repair_status': repair_status,
                'total_actions_attempted': total_actions,
                'successful_actions': successful_actions,
                'success_rate_percentage': success_rate,
                'execution_time_seconds': repair_results.get('total_execution_time', 0),
                'changes_committed': os.environ.get('changes_committed', 'false') == 'true'
            }
            
            # Generate recommendations
            recommendations = []
            
            if repair_status == 'failed':
                recommendations.append({
                    'priority': 'high',
                    'category': 'manual_intervention',
                    'recommendation': 'Manual intervention required - automated repair failed'
                })
                recommendations.append({
                    'priority': 'medium', 
                    'category': 'investigation',
                    'recommendation': 'Review failure analysis and repair logs for root cause'
                })
            elif repair_status == 'partially_successful':
                recommendations.append({
                    'priority': 'medium',
                    'category': 'review',
                    'recommendation': 'Review partially successful repairs and apply remaining fixes manually'
                })
            else:
                recommendations.append({
                    'priority': 'low',
                    'category': 'monitoring',
                    'recommendation': 'Continue monitoring for any remaining issues'
                })
            
            # Add improvement recommendations
            if success_rate < 75:
                recommendations.append({
                    'priority': 'medium',
                    'category': 'optimization',
                    'recommendation': 'Consider enhancing auto-repair algorithms for better success rate'
                })
            
            report_data['recommendations'] = recommendations
            
            # Save comprehensive report
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            report_filename = f'auto_repair_report_{timestamp}.json'
            
            with open(f'.github/automation/reports/{report_filename}', 'w') as f:
                json.dump(report_data, f, indent=2, default=str)
            
            # Generate Markdown summary
            markdown_summary = generate_markdown_summary(report_data)
            markdown_filename = f'auto_repair_summary_{timestamp}.md'
            
            with open(f'.github/automation/reports/{markdown_filename}', 'w') as f:
                f.write(markdown_summary)
            
            print(f'[OK] Comprehensive report saved: {report_filename}')
            print(f'[OK] Markdown summary saved: {markdown_filename}')
            
            # Output summary to GitHub step summary
            github_summary = os.environ.get('GITHUB_STEP_SUMMARY')
            if github_summary:
                with open(github_summary, 'w') as f:
                    f.write(markdown_summary)
                print('[OK] Updated GitHub step summary')
        
        def generate_markdown_summary(report_data):
            \"\"\"Generate formatted Markdown summary of repair results\"\"\"
            metadata = report_data['metadata']
            summary = report_data['summary']
            
            # Header with status emoji
            status_emoji = {
                'successful': '[OK]',
                'partially_successful': '[WARN]', 
                'failed': '[FAIL]'
            }.get(summary['repair_status'], '❓')
            
            markdown_lines = [
                f'# {status_emoji} Auto-Repair Report - {summary[\"repair_status\"].replace(\"_\", \" \").title()}',
                '',
                f'**Generated**: {metadata[\"generated_at\"]}',
                f'**Repository**: {metadata[\"repository\"]}',
                f'**Workflow**: {metadata[\"workflow_run_id\"]}',
                f'**Repair Mode**: {metadata[\"repair_mode\"].title()}',
                f'**Trigger**: {metadata[\"trigger_mode\"].replace(\"_\", \" \").title()}',
                '',
                '## [CHART] Repair Summary',
                '',
                f'- **Status**: {summary[\"repair_status\"].replace(\"_\", \" \").title()}',
                f'- **Actions Attempted**: {summary[\"total_actions_attempted\"]}',
                f'- **Actions Successful**: {summary[\"successful_actions\"]}',
                f'- **Success Rate**: {summary[\"success_rate_percentage\"]:.1f}%',
                f'- **Execution Time**: {summary[\"execution_time_seconds\"]:.2f} seconds',
                f'- **Changes Committed**: {\"Yes\" if summary[\"changes_committed\"] else \"No\"}',
                ''
            ]
            
            # Add repair actions details if available
            repair_results = report_data.get('repair_results', {})
            actions_attempted = repair_results.get('actions_attempted', [])
            
            if actions_attempted:
                markdown_lines.extend([
                    '## [WRENCH] Repair Actions Performed',
                    ''
                ])
                
                for i, action in enumerate(actions_attempted, 1):
                    success_emoji = '[OK]' if action.get('success', False) else '[FAIL]'
                    action_type = action.get('action_type', 'unknown').replace('_', ' ').title()
                    description = action.get('description', 'No description')
                    execution_time = action.get('execution_time', 0)
                    
                    markdown_lines.extend([
                        f'### {i}. {success_emoji} {action_type}',
                        f'- **Description**: {description}',
                        f'- **Execution Time**: {execution_time:.2f}s',
                        f'- **Status**: {action.get(\"status\", \"unknown\").title()}',
                        ''
                    ])
            
            # Add recommendations
            recommendations = report_data.get('recommendations', [])
            if recommendations:
                markdown_lines.extend([
                    '## [BULB] Recommendations',
                    ''
                ])
                
                for rec in recommendations:
                    priority_emoji = {'high': '🔴', 'medium': '🟡', 'low': '🟢'}.get(rec['priority'], '⚪')
                    markdown_lines.append(f'- {priority_emoji} **{rec[\"category\"].replace(\"_\", \" \").title()}**: {rec[\"recommendation\"]}')
            
            markdown_lines.extend([
                '',
                '---',
                '*This report was generated automatically by the Enhanced Auto-Repair with Closed-Loop Integration system.*'
            ])
            
            return '\\n'.join(markdown_lines)
        
        # Create reports directory
        Path('.github/automation/reports').mkdir(parents=True, exist_ok=True)
        
        generate_comprehensive_report()
        "
        
        echo "::endgroup::"

    - name: Enhanced PR Comment with Closed-Loop Results
      if: github.event.workflow_run.event == 'pull_request' || github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          
          // Load repair results
          let repairData = {};
          try {
            if (fs.existsSync('.github/automation/repair_results.json')) {
              repairData = JSON.parse(fs.readFileSync('.github/automation/repair_results.json', 'utf8'));
            }
          } catch (error) {
            console.log('Could not load repair results:', error.message);
          }
          
          // Determine status and emoji
          const repairStatus = repairData.repair_status || 'unknown';
          const statusEmojis = {
            'successful': '[OK]',
            'partially_successful': '[WARN]',
            'failed': '[FAIL]'
          };
          const statusEmoji = statusEmojis[repairStatus] || '❓';
          
          // Generate comment body
          const totalActions = repairData.total_actions || 0;
          const successfulActions = repairData.successful_actions || 0;
          const successRate = repairData.success_rate || 0;
          const executionTime = repairData.total_execution_time || 0;
          
          const commentBody = `${statusEmoji} **Enhanced Auto-Repair with Closed-Loop Integration**
          
**Status**: ${repairStatus.replace('_', ' ').charAt(0).toUpperCase() + repairStatus.replace('_', ' ').slice(1)}
**Actions Taken**: ${totalActions}
**Success Rate**: ${successRate.toFixed(1)}%
**Execution Time**: ${executionTime.toFixed(2)}s
          
### [WRENCH] Repair Actions Performed:
${repairData.actions_attempted ? repairData.actions_attempted.map((action, index) => 
  `${index + 1}. ${action.success ? '[OK]' : '[FAIL]'} **${action.action_type.replace('_', ' ')}**: ${action.description}`
).join('\n') : 'No detailed action information available'}
          
### [CHART] Integration Features:
- **Intelligent Failure Detection**: Real-time CI/CD failure analysis
- **Category-based Recovery**: Targeted repair strategies by failure type
- **Exponential Backoff**: Smart retry mechanisms for transient failures
- **Quality Gate Integration**: Seamless integration with existing quality workflows
- **Real-time Status Updates**: Live feedback via GitHub status checks
          
### 🔗 Workflow Integration:
- **Triggered by**: ${context.eventName === 'workflow_run' ? 'Failed workflow: ' + (process.env.failed_workflow || 'Unknown') : 'Manual execution'}
- **Recovery Mode**: ${process.env.REPAIR_MODE || 'automatic'}
- **Closed-Loop**: ${totalActions > 0 ? 'Fully operational' : 'Analysis only'}
          
---
*Enhanced Auto-Repair powered by Closed-Loop GitHub Automation v2.0.0*
*🤖 Generated with [Claude Code](https://claude.ai/code)*`;
          
          // Create comment
          const { owner, repo } = context.repo;
          
          try {
            // Try to get PR number from context or environment
            let issueNumber;
            
            if (context.eventName === 'pull_request') {
              issueNumber = context.issue.number;
            } else if (process.env.GITHUB_REF && process.env.GITHUB_REF.startsWith('refs/pull/')) {
              issueNumber = parseInt(process.env.GITHUB_REF.split('/')[2]);
            }
            
            if (issueNumber) {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: issueNumber,
                body: commentBody
              });
              console.log(`Created enhanced auto-repair comment on PR #${issueNumber}`);
            } else {
              console.log('No PR number available for comment');
            }
            
          } catch (error) {
            console.log('Could not create PR comment:', error.message);
          }

    - name: Upload Comprehensive Repair Artifacts
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: enhanced-auto-repair-results-${{ github.run_number }}
        path: |
          .github/automation/
          .claude/.artifacts/repair/
        retention-days: 30