name: Automated Rollback & Circuit Breaker
on:
  workflow_run:
    workflows: [
      "Quality Analysis Orchestrator",
      "Quality Analysis Orchestrator (Parallel Optimized)",
      "Security Pipeline (Standardized)",
      "Enhanced Quality Gates (Phase 3)"
    ]
    types: [completed]
  schedule:
    - cron: '*/30 * * * *'  # Every 30 minutes
  workflow_dispatch:
    inputs:
      action:
        description: 'Rollback action'
        required: false
        default: 'check'
        type: choice
        options:
          - check
          - force_rollback
          - reset_circuit_breakers
          - health_check

jobs:
  circuit-breaker-analysis:
    runs-on: ubuntu-latest
    name: "Circuit Breaker Analysis"
    timeout-minutes: 15
    
    outputs:
      rollback_required: ${{ steps.analysis.outputs.rollback_required }}
      circuit_breaker_status: ${{ steps.analysis.outputs.circuit_breaker_status }}
      failure_threshold_exceeded: ${{ steps.analysis.outputs.failure_threshold_exceeded }}
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.12'

    - name: Create Rollback Artifacts Directory
      run: mkdir -p .claude/.artifacts/rollback

    - name: Analyze Circuit Breaker Status
      id: analysis
      run: |
        echo "Analyzing circuit breaker status and failure patterns..."
        python -c "
        import json
        import subprocess
        import sys
        import os
        from datetime import datetime, timedelta
        from pathlib import Path
        
        class CircuitBreakerAnalyzer:
            def __init__(self):
                self.circuit_breaker_config = {
                    'failure_threshold': 2,  # 2 consecutive failures trigger circuit breaker
                    'success_threshold': 3,  # 3 consecutive successes reset circuit breaker
                    'timeout_minutes': 60,   # Circuit breaker timeout period
                    'rollback_threshold': 3  # 3 workflows in circuit breaker state trigger rollback
                }
                
                self.analysis_result = {
                    'timestamp': datetime.now().isoformat(),
                    'analysis_type': 'circuit_breaker_analysis',
                    'workflow_states': {},
                    'circuit_breakers': {},
                    'rollback_decision': {
                        'rollback_required': False,
                        'rollback_reason': '',
                        'affected_workflows': []
                    },
                    'recommendations': []
                }
            
            def load_existing_circuit_breaker_state(self):
                '''Load existing circuit breaker state from artifacts'''
                cb_file = Path('.claude/.artifacts/rollback/circuit_breaker_state.json')
                
                if cb_file.exists():
                    try:
                        with open(cb_file, 'r') as f:
                            return json.load(f)
                    except Exception as e:
                        print(f'Warning: Could not load circuit breaker state: {e}')
                
                return {}
            
            def save_circuit_breaker_state(self, state):
                '''Save circuit breaker state to artifacts'''
                cb_file = Path('.claude/.artifacts/rollback/circuit_breaker_state.json')
                cb_file.parent.mkdir(exist_ok=True)
                
                try:
                    with open(cb_file, 'w') as f:
                        json.dump(state, f, indent=2, default=str)
                except Exception as e:
                    print(f'Warning: Could not save circuit breaker state: {e}')
            
            def get_workflow_run_history(self):
                '''Get recent workflow run history for analysis'''
                workflow_history = {}
                
                try:
                    # Get recent workflow runs
                    result = subprocess.run(
                        ['gh', 'run', 'list', '--limit', '50', '--json', 
                         'status,conclusion,name,createdAt,workflowName,url'],
                        capture_output=True, text=True, timeout=60
                    )
                    
                    if result.returncode == 0:
                        runs = json.loads(result.stdout)
                        
                        # Group by workflow name
                        for run in runs:
                            workflow_name = run.get('workflowName', run.get('name', 'unknown'))
                            
                            if workflow_name not in workflow_history:
                                workflow_history[workflow_name] = []
                            
                            workflow_history[workflow_name].append({
                                'status': run.get('status'),
                                'conclusion': run.get('conclusion'),
                                'created_at': run.get('createdAt'),
                                'url': run.get('url')
                            })
                
                except Exception as e:
                    print(f'Warning: Could not get workflow history: {e}')
                    # Fallback to estimated data
                    return self._get_fallback_workflow_history()
                
                return workflow_history
            
            def _get_fallback_workflow_history(self):
                '''Fallback workflow history when GitHub API unavailable'''
                # Load monitoring data if available
                monitoring_file = Path('.claude/.artifacts/monitoring/workflow_health_dashboard.json')
                
                if monitoring_file.exists():
                    try:
                        with open(monitoring_file, 'r') as f:
                            monitoring_data = json.load(f)
                        
                        fallback_history = {}
                        
                        for workflow_name, workflow_data in monitoring_data.get('workflow_status', {}).items():
                            success_rate = workflow_data.get('success_rate', 0.8)
                            total_runs = workflow_data.get('total_runs', 5)
                            
                            # Generate synthetic history based on success rate
                            history = []
                            for i in range(total_runs):
                                # Simulate run results based on success rate
                                is_success = (i / total_runs) < success_rate
                                history.append({
                                    'status': 'completed',
                                    'conclusion': 'success' if is_success else 'failure',
                                    'created_at': datetime.now().isoformat(),
                                    'url': f'synthetic-run-{i}'
                                })
                            
                            fallback_history[workflow_name] = history
                        
                        return fallback_history
                    
                    except Exception as e:
                        print(f'Warning: Could not load monitoring data: {e}')
                
                return {}
            
            def analyze_workflow_patterns(self, workflow_history):
                '''Analyze workflow failure patterns for circuit breaker decisions'''
                current_cb_state = self.load_existing_circuit_breaker_state()
                updated_cb_state = current_cb_state.copy()
                
                for workflow_name, runs in workflow_history.items():
                    if not runs:
                        continue
                    
                    # Sort runs by creation time (most recent first)
                    sorted_runs = sorted(runs, key=lambda x: x.get('created_at', ''), reverse=True)
                    
                    # Analyze consecutive failures/successes
                    consecutive_failures = 0
                    consecutive_successes = 0
                    
                    for run in sorted_runs:
                        conclusion = run.get('conclusion')
                        
                        if conclusion == 'failure':
                            consecutive_failures += 1
                            consecutive_successes = 0  # Reset success counter
                        elif conclusion == 'success':
                            consecutive_successes += 1
                            break  # Stop counting after first success
                        else:
                            break  # Stop on inconclusive results
                    
                    # Current circuit breaker state for this workflow
                    current_state = current_cb_state.get(workflow_name, {
                        'state': 'closed',  # closed, open, half_open
                        'failure_count': 0,
                        'success_count': 0,
                        'last_failure_time': None,
                        'circuit_opened_time': None
                    })
                    
                    # Circuit breaker state machine logic
                    new_state = current_state.copy()
                    
                    if current_state['state'] == 'closed':
                        # Normal operation
                        if consecutive_failures >= self.circuit_breaker_config['failure_threshold']:
                            # Open circuit breaker
                            new_state['state'] = 'open'
                            new_state['failure_count'] = consecutive_failures
                            new_state['circuit_opened_time'] = datetime.now().isoformat()
                            new_state['last_failure_time'] = sorted_runs[0].get('created_at')
                        else:
                            new_state['failure_count'] = consecutive_failures
                    
                    elif current_state['state'] == 'open':
                        # Circuit breaker is open
                        opened_time = current_state.get('circuit_opened_time')
                        
                        if opened_time:
                            try:
                                opened_dt = datetime.fromisoformat(opened_time.replace('Z', '+00:00'))
                                time_since_opened = (datetime.now() - opened_dt.replace(tzinfo=None)).total_seconds() / 60
                                
                                if time_since_opened >= self.circuit_breaker_config['timeout_minutes']:
                                    # Try half-open state
                                    new_state['state'] = 'half_open'
                            except:
                                pass
                    
                    elif current_state['state'] == 'half_open':
                        # Testing if service has recovered
                        if consecutive_successes >= self.circuit_breaker_config['success_threshold']:
                            # Close circuit breaker - service recovered
                            new_state['state'] = 'closed'
                            new_state['failure_count'] = 0
                            new_state['success_count'] = consecutive_successes
                        elif consecutive_failures > 0:
                            # Open circuit breaker again - service still failing
                            new_state['state'] = 'open'
                            new_state['failure_count'] = consecutive_failures
                            new_state['circuit_opened_time'] = datetime.now().isoformat()
                    
                    updated_cb_state[workflow_name] = new_state
                    
                    # Record analysis for this workflow
                    self.analysis_result['workflow_states'][workflow_name] = {
                        'consecutive_failures': consecutive_failures,
                        'consecutive_successes': consecutive_successes,
                        'circuit_breaker_state': new_state['state'],
                        'recent_runs': len(sorted_runs),
                        'failure_count': new_state['failure_count']
                    }
                    
                    self.analysis_result['circuit_breakers'][workflow_name] = new_state
                
                # Save updated circuit breaker state
                self.save_circuit_breaker_state(updated_cb_state)
                
                return updated_cb_state
            
            def make_rollback_decision(self, circuit_breaker_state):
                '''Make rollback decision based on circuit breaker analysis'''
                open_circuit_breakers = []
                critical_failures = []
                
                for workflow_name, state in circuit_breaker_state.items():
                    if state['state'] == 'open':
                        open_circuit_breakers.append(workflow_name)
                        
                        # Check for critical workflows
                        critical_workflows = [
                            'Quality Analysis Orchestrator',
                            'Security Pipeline (Standardized)',
                            'Enhanced Quality Gates (Phase 3)'
                        ]
                        
                        if any(critical in workflow_name for critical in critical_workflows):
                            critical_failures.append(workflow_name)
                
                # Rollback decision logic
                rollback_required = False
                rollback_reason = ''
                
                if len(critical_failures) > 0:
                    rollback_required = True
                    rollback_reason = f'Critical workflows failing: {critical_failures}'
                elif len(open_circuit_breakers) >= self.circuit_breaker_config['rollback_threshold']:
                    rollback_required = True
                    rollback_reason = f'{len(open_circuit_breakers)} workflows in circuit breaker state'
                
                self.analysis_result['rollback_decision'] = {
                    'rollback_required': rollback_required,
                    'rollback_reason': rollback_reason,
                    'affected_workflows': open_circuit_breakers,
                    'critical_failures': critical_failures,
                    'open_circuit_breakers': len(open_circuit_breakers)
                }
                
                return rollback_required, rollback_reason, open_circuit_breakers
            
            def generate_recommendations(self):
                '''Generate recommendations based on analysis'''
                recommendations = []
                rollback_decision = self.analysis_result['rollback_decision']
                
                if rollback_decision['rollback_required']:
                    recommendations.append(f'IMMEDIATE ACTION: {rollback_decision[\"rollback_reason\"]}')
                    recommendations.append('Execute automated rollback to last known good configuration')
                
                open_cbs = rollback_decision['open_circuit_breakers']
                if open_cbs > 0:
                    recommendations.append(f'Monitor {open_cbs} workflows in circuit breaker state')
                
                critical_failures = rollback_decision.get('critical_failures', [])
                if critical_failures:
                    recommendations.append(f'Priority fix required for critical workflows: {critical_failures}')
                
                # Preventive recommendations
                if open_cbs == 0 and not rollback_decision['rollback_required']:
                    recommendations.append('All circuit breakers healthy - continue monitoring')
                
                self.analysis_result['recommendations'] = recommendations
            
            def run_analysis(self):
                '''Run complete circuit breaker analysis'''
                print('Getting workflow run history...')
                workflow_history = self.get_workflow_run_history()
                
                print('Analyzing workflow patterns...')
                circuit_breaker_state = self.analyze_workflow_patterns(workflow_history)
                
                print('Making rollback decision...')
                rollback_required, rollback_reason, affected_workflows = self.make_rollback_decision(circuit_breaker_state)
                
                print('Generating recommendations...')
                self.generate_recommendations()
                
                return self.analysis_result
        
        # Run circuit breaker analysis
        analyzer = CircuitBreakerAnalyzer()
        results = analyzer.run_analysis()
        
        # Save analysis results
        with open('.claude/.artifacts/rollback/circuit_breaker_analysis.json', 'w') as f:
            json.dump(results, f, indent=2, default=str)
        
        # Set GitHub Actions outputs
        rollback_required = results['rollback_decision']['rollback_required']
        open_circuit_breakers = results['rollback_decision']['open_circuit_breakers']
        
        print(f'::set-output name=rollback_required::{str(rollback_required).lower()}')
        print(f'::set-output name=circuit_breaker_status::{open_circuit_breakers}')
        print(f'::set-output name=failure_threshold_exceeded::{str(open_circuit_breakers >= 2).lower()}')
        
        # Summary output
        print(f'Circuit Breaker Analysis Complete')
        print(f'Rollback Required: {rollback_required}')
        print(f'Open Circuit Breakers: {open_circuit_breakers}')
        if rollback_required:
            print(f'Rollback Reason: {results[\"rollback_decision\"][\"rollback_reason\"]}')
        "

    - name: Upload Circuit Breaker Analysis
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: circuit-breaker-analysis-${{ github.run_number }}
        path: |
          .claude/.artifacts/rollback/circuit_breaker_analysis.json
          .claude/.artifacts/rollback/circuit_breaker_state.json

  # Automated rollback execution (only if required)
  execute-rollback:
    needs: circuit-breaker-analysis
    runs-on: ubuntu-latest-4-core
    name: "Execute Automated Rollback"
    timeout-minutes: 30
    if: needs.circuit-breaker-analysis.outputs.rollback_required == 'true' || github.event.inputs.action == 'force_rollback'
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Full history for rollback

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.12'

    - name: Download Circuit Breaker Analysis
      uses: actions/download-artifact@v4
      with:
        name: circuit-breaker-analysis-${{ github.run_number }}
        path: .claude/.artifacts/rollback/

    - name: Create Rollback Strategy
      run: |
        echo "Creating rollback strategy based on circuit breaker analysis..."
        python -c "
        import json
        import subprocess
        import sys
        from datetime import datetime
        from pathlib import Path
        
        class AutomatedRollback:
            def __init__(self):
                self.rollback_strategy = {
                    'timestamp': datetime.now().isoformat(),
                    'rollback_type': 'automated_circuit_breaker',
                    'rollback_plan': {},
                    'backup_created': False,
                    'rollback_executed': False,
                    'verification_results': {}
                }
                
                # Load circuit breaker analysis
                self.load_analysis()
            
            def load_analysis(self):
                '''Load circuit breaker analysis results'''
                analysis_file = Path('.claude/.artifacts/rollback/circuit_breaker_analysis.json')
                
                if analysis_file.exists():
                    try:
                        with open(analysis_file, 'r') as f:
                            self.analysis = json.load(f)
                    except Exception as e:
                        print(f'Warning: Could not load analysis: {e}')
                        self.analysis = {}
                else:
                    self.analysis = {}
            
            def create_rollback_plan(self):
                '''Create specific rollback plan based on failing workflows'''
                rollback_decision = self.analysis.get('rollback_decision', {})
                affected_workflows = rollback_decision.get('affected_workflows', [])
                
                rollback_actions = []
                
                # Identify rollback actions for each affected workflow
                for workflow_name in affected_workflows:
                    if 'parallel' in workflow_name.lower():
                        # Rollback from parallel to sequential orchestrator
                        rollback_actions.append({
                            'action': 'disable_workflow',
                            'workflow': workflow_name,
                            'fallback': 'Quality Analysis Orchestrator',
                            'priority': 'high'
                        })
                    
                    elif 'security' in workflow_name.lower():
                        # Rollback security pipeline to basic version
                        rollback_actions.append({
                            'action': 'rollback_security_config',
                            'workflow': workflow_name,
                            'fallback': 'basic_security_validation',
                            'priority': 'critical'
                        })
                    
                    elif 'quality' in workflow_name.lower():
                        # Rollback quality gates to Phase 1 version
                        rollback_actions.append({
                            'action': 'rollback_quality_gates',
                            'workflow': workflow_name,
                            'fallback': 'Quality Gates',
                            'priority': 'high'
                        })
                
                # Add system-wide rollback actions
                if len(affected_workflows) >= 3:
                    rollback_actions.append({
                        'action': 'system_wide_rollback',
                        'description': 'Multiple critical failures - rollback to Phase 1 configuration',
                        'priority': 'critical'
                    })
                
                self.rollback_strategy['rollback_plan'] = {
                    'affected_workflows': affected_workflows,
                    'rollback_actions': rollback_actions,
                    'rollback_reason': rollback_decision.get('rollback_reason', 'Circuit breaker triggered'),
                    'estimated_rollback_time_minutes': len(rollback_actions) * 2
                }
                
                return rollback_actions
            
            def create_configuration_backup(self):
                '''Create backup of current configuration before rollback'''
                try:
                    # Create backup branch
                    backup_branch = f'rollback-backup-{datetime.now().strftime(\"%Y%m%d-%H%M%S\")}'
                    
                    subprocess.run(['git', 'checkout', '-b', backup_branch], check=True)
                    subprocess.run(['git', 'push', 'origin', backup_branch], check=True)
                    
                    self.rollback_strategy['backup_created'] = True
                    self.rollback_strategy['backup_branch'] = backup_branch
                    
                    # Return to main branch
                    subprocess.run(['git', 'checkout', 'main'], check=True)
                    
                    print(f'Backup created: {backup_branch}')
                    return True
                    
                except Exception as e:
                    print(f'Warning: Could not create backup: {e}')
                    return False
            
            def execute_rollback_actions(self, rollback_actions):
                '''Execute the planned rollback actions'''
                executed_actions = []
                
                for action in rollback_actions:
                    try:
                        action_type = action['action']
                        
                        if action_type == 'disable_workflow':
                            # Disable workflow by renaming file
                            workflow_name = action['workflow']
                            workflow_files = list(Path('.github/workflows').glob('*.yml'))
                            
                            for workflow_file in workflow_files:
                                if workflow_name.lower() in workflow_file.stem.lower():
                                    disabled_file = workflow_file.with_name(f'{workflow_file.stem}.disabled')
                                    workflow_file.rename(disabled_file)
                                    executed_actions.append(f'Disabled {workflow_file.name}')
                                    break
                        
                        elif action_type == 'rollback_security_config':
                            # Remove advanced security configurations
                            security_files = [
                                '.github/workflows/security-pipeline.yml',
                                '.github/workflows/config/security-hardening.yml'
                            ]
                            
                            for sec_file in security_files:
                                sec_path = Path(sec_file)
                                if sec_path.exists():
                                    sec_path.rename(sec_path.with_suffix('.yml.disabled'))
                                    executed_actions.append(f'Disabled {sec_file}')
                        
                        elif action_type == 'rollback_quality_gates':
                            # Disable enhanced quality gates
                            enhanced_gates = Path('.github/workflows/enhanced-quality-gates.yml')
                            if enhanced_gates.exists():
                                enhanced_gates.rename(enhanced_gates.with_suffix('.yml.disabled'))
                                executed_actions.append('Disabled enhanced quality gates')
                        
                        elif action_type == 'system_wide_rollback':
                            # Disable all Phase 2/3 enhancements
                            phase23_files = [
                                '.github/workflows/quality-orchestrator-parallel.yml',
                                '.github/workflows/security-pipeline.yml',
                                '.github/workflows/enhanced-quality-gates.yml',
                                '.github/workflows/monitoring-dashboard.yml'
                            ]
                            
                            for p23_file in phase23_files:
                                p23_path = Path(p23_file)
                                if p23_path.exists():
                                    p23_path.rename(p23_path.with_suffix('.yml.rollback'))
                                    executed_actions.append(f'Rolled back {p23_file}')
                    
                    except Exception as e:
                        print(f'Warning: Could not execute action {action}: {e}')
                
                self.rollback_strategy['rollback_executed'] = len(executed_actions) > 0
                self.rollback_strategy['executed_actions'] = executed_actions
                
                return executed_actions
            
            def commit_rollback_changes(self, executed_actions):
                '''Commit rollback changes to repository'''
                if not executed_actions:
                    return False
                
                try:
                    # Stage all changes
                    subprocess.run(['git', 'add', '.'], check=True)
                    
                    # Commit rollback
                    commit_message = f'''Automated rollback due to circuit breaker activation
                    
                    Rollback actions executed:
                    {chr(10).join(f'- {action}' for action in executed_actions)}
                    
                    Rollback triggered by: {self.rollback_strategy['rollback_plan']['rollback_reason']}
                    Generated with Claude Code Circuit Breaker System
                    '''
                    
                    subprocess.run(['git', 'commit', '-m', commit_message], check=True)
                    subprocess.run(['git', 'push', 'origin', 'main'], check=True)
                    
                    return True
                    
                except Exception as e:
                    print(f'Warning: Could not commit rollback changes: {e}')
                    return False
            
            def verify_rollback_success(self):
                '''Verify that rollback was successful'''
                verification_results = {
                    'rollback_committed': False,
                    'workflows_disabled': 0,
                    'system_stable': False
                }
                
                try:
                    # Check git status
                    result = subprocess.run(['git', 'status', '--porcelain'], 
                                          capture_output=True, text=True)
                    
                    verification_results['rollback_committed'] = len(result.stdout.strip()) == 0
                    
                    # Count disabled workflows
                    disabled_files = list(Path('.github/workflows').glob('*.disabled')) + \
                                   list(Path('.github/workflows').glob('*.rollback'))
                    verification_results['workflows_disabled'] = len(disabled_files)
                    
                    # System stability check (basic)
                    verification_results['system_stable'] = verification_results['workflows_disabled'] > 0
                
                except Exception as e:
                    print(f'Warning: Could not verify rollback: {e}')
                
                self.rollback_strategy['verification_results'] = verification_results
                return verification_results
            
            def run_rollback(self):
                '''Execute complete automated rollback process'''
                print('Creating rollback plan...')
                rollback_actions = self.create_rollback_plan()
                
                print('Creating configuration backup...')
                backup_success = self.create_configuration_backup()
                
                if not backup_success:
                    print('WARNING: Could not create backup - proceeding with rollback')
                
                print('Executing rollback actions...')
                executed_actions = self.execute_rollback_actions(rollback_actions)
                
                if executed_actions:
                    print('Committing rollback changes...')
                    commit_success = self.commit_rollback_changes(executed_actions)
                    
                    if commit_success:
                        print('Verifying rollback success...')
                        self.verify_rollback_success()
                
                return self.rollback_strategy
        
        # Execute automated rollback
        rollback = AutomatedRollback()
        rollback_result = rollback.run_rollback()
        
        # Save rollback results
        with open('.claude/.artifacts/rollback/automated_rollback_result.json', 'w') as f:
            json.dump(rollback_result, f, indent=2, default=str)
        
        print('Automated Rollback Complete')
        print(f'Actions Executed: {len(rollback_result.get(\"executed_actions\", []))}')
        print(f'Rollback Success: {rollback_result[\"rollback_executed\"]}')
        "

    - name: Post-Rollback Notification
      if: always()
      run: |
        echo "=== Automated Rollback Notification ==="
        python -c "
        import json
        from pathlib import Path
        
        # Load rollback results
        rollback_file = Path('.claude/.artifacts/rollback/automated_rollback_result.json')
        
        if rollback_file.exists():
            with open(rollback_file, 'r') as f:
                rollback_data = json.load(f)
            
            executed_actions = rollback_data.get('executed_actions', [])
            rollback_reason = rollback_data.get('rollback_plan', {}).get('rollback_reason', 'Unknown')
            verification = rollback_data.get('verification_results', {})
            
            print(f'AUTOMATED ROLLBACK EXECUTED')
            print(f'Trigger: {rollback_reason}')
            print(f'Actions: {len(executed_actions)}')
            print(f'Status: {\"SUCCESS\" if rollback_data[\"rollback_executed\"] else \"FAILED\"}')
            
            if executed_actions:
                print('\\nRollback Actions:')
                for action in executed_actions:
                    print(f'  - {action}')
            
            print(f'\\nVerification:')
            print(f'  - Changes Committed: {verification.get(\"rollback_committed\", False)}')
            print(f'  - Workflows Disabled: {verification.get(\"workflows_disabled\", 0)}')
            print(f'  - System Stable: {verification.get(\"system_stable\", False)}')
        
        else:
            print('No rollback results found')
        "

    - name: Upload Rollback Results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: automated-rollback-results-${{ github.run_number }}
        path: |
          .claude/.artifacts/rollback/

  # Health check after rollback (if executed)
  post-rollback-health-check:
    needs: [circuit-breaker-analysis, execute-rollback]
    runs-on: ubuntu-latest
    name: "Post-Rollback Health Check"
    timeout-minutes: 15
    if: always() && (needs.execute-rollback.result == 'success' || needs.circuit-breaker-analysis.outputs.failure_threshold_exceeded == 'true')
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4

    - name: Run System Health Check
      run: |
        echo "Running post-rollback system health check..."
        python -c "
        import json
        import subprocess
        from datetime import datetime
        from pathlib import Path
        
        # Basic health check after rollback
        health_check = {
            'timestamp': datetime.now().isoformat(),
            'check_type': 'post_rollback_health',
            'workflow_files_active': 0,
            'workflow_files_disabled': 0,
            'system_status': 'unknown'
        }
        
        workflows_dir = Path('.github/workflows')
        if workflows_dir.exists():
            active_workflows = list(workflows_dir.glob('*.yml'))
            disabled_workflows = list(workflows_dir.glob('*.disabled')) + \
                               list(workflows_dir.glob('*.rollback'))
            
            health_check['workflow_files_active'] = len(active_workflows)
            health_check['workflow_files_disabled'] = len(disabled_workflows)
            
            # System status assessment
            if len(active_workflows) >= 5:  # Minimum viable workflows
                health_check['system_status'] = 'stable'
            elif len(active_workflows) >= 3:
                health_check['system_status'] = 'degraded'
            else:
                health_check['system_status'] = 'critical'
        
        print(f'Post-Rollback Health Check:')
        print(f'Active Workflows: {health_check[\"workflow_files_active\"]}')
        print(f'Disabled Workflows: {health_check[\"workflow_files_disabled\"]}')
        print(f'System Status: {health_check[\"system_status\"].upper()}')
        
        # Save health check results
        Path('.claude/.artifacts/rollback').mkdir(exist_ok=True, parents=True)
        with open('.claude/.artifacts/rollback/post_rollback_health_check.json', 'w') as f:
            json.dump(health_check, f, indent=2, default=str)
        "

    - name: Upload Health Check Results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: post-rollback-health-check-${{ github.run_number }}
        path: |
          .claude/.artifacts/rollback/post_rollback_health_check.json