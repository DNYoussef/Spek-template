name: after-edit
description: QA loop with CF swarm coordination, attempt capping, and neural pattern recognition.
environment:
  HIVE_NAMESPACE: "spek/after-edit/$(date +%Y%m%d)"
  SESSION_ID: "swarm-$(git branch --show-current || echo 'main')"
  MAX_ATTEMPTS: "${AUTO_REPAIR_MAX_ATTEMPTS:-2}"
steps:
  # Swarm Burst Control Initialization
  - id: init_swarm
    run: |
      npx claude-flow@alpha swarm init --topology hierarchical --burst-control --max-attempts "$MAX_ATTEMPTS"
      npx claude-flow@alpha swarm status --session "$SESSION_ID" > swarm_status.json || echo '{"attempts": 0}' > swarm_status.json
      CURRENT_ATTEMPTS="$(jq -r '.attempts // 0' swarm_status.json)"
      if [[ $CURRENT_ATTEMPTS -ge $MAX_ATTEMPTS ]]; then
        echo "üö® Max attempts ($MAX_ATTEMPTS) exceeded - escalating to planner"
        npx claude-flow@alpha task orchestrate --escalate planner --reason "auto-repair-limit"
        exit 1
      fi
    capture: swarm_init.json
  - id: plan
    run: claude /spec:plan
    capture: plan.json
    expect_json: true

  - id: implement_small
    foreach: plan.json.tasks
    when: item.type == "small"
    run: claude /codex:micro "${{ item.title }}"

  - id: discover_big
    foreach: plan.json.tasks
    when: item.type == "big"
    run: claude /gemini:impact "${{ item.scope }}"
    capture: "gemini/${{ item.id }}.json"

  - id: implement_multi
    foreach: plan.json.tasks
    when: item.type == "multi"
    run: claude /fix:planned "${{ item.title }}"

  # Self-Correcting Quality Loop
  - id: self_correct_loop
    run: |
      export HIVE_NAMESPACE="$HIVE_NAMESPACE"
      export SESSION_ID="$SESSION_ID"
      export MAX_ATTEMPTS="$MAX_ATTEMPTS"
      export SHOW_LOGS=1
      
      # Run bounded self-correction
      bash scripts/self_correct.sh
    capture: .claude/.artifacts/gate.json
    expect_json: true

  - id: pass_gate
    when: $.self_correct_loop.ok == true
    run: |
      npx claude-flow@alpha neural train --model success_patterns --session "$SESSION_ID" --input "$(git diff --stat)" 2>/dev/null || true
      npx claude-flow@alpha swarm status --update-success --session "$SESSION_ID" 2>/dev/null || true
      claude /pr:open
    exit: 0

  - id: failure_analysis
    when: $.self_correct_loop.ok == false
    run: |
      echo "‚ùå Self-correction loop failed after $MAX_ATTEMPTS attempts"
      
      # Generate detailed failure report
      chmod +x scripts/gate_fail_reason.sh
      scripts/gate_fail_reason.sh .claude/.artifacts/gate.json plain
      
      # Show what was attempted
      echo ""
      echo "üîÑ Self-correction attempts made:"
      if [[ -f .claude/.artifacts/current_attempt.json ]]; then
        jq . .claude/.artifacts/current_attempt.json
      fi

  # Neural Learning and Session Management
  - id: learn_from_failure
    when: gate.json.ok == false
    run: |
      npx claude-flow@alpha neural train --model failure_patterns --session "$SESSION_ID" --input "$(cat triage.json)"
      npx claude-flow@alpha memory store --key "failures/$(date +%s)" --value "$(cat triage.json)" --namespace "$HIVE_NAMESPACE"
      CURRENT_ATTEMPTS="$(npx claude-flow@alpha swarm status --session '$SESSION_ID' --json | jq -r '.attempts // 0')"
      if [[ $CURRENT_ATTEMPTS -ge $MAX_ATTEMPTS ]]; then
        echo "üö® Escalating to architecture phase after $CURRENT_ATTEMPTS attempts"
        npx claude-flow@alpha task orchestrate --escalate architecture --reason "repeated-failure" --context "$(cat triage.json)"
      fi
    capture: learn_results.json